{"mappings":"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","sources":["packages/react-resizable-panels/src/index.ts","packages/react-resizable-panels/src/Panel.ts","packages/react-resizable-panels/src/env-conditions/browser.ts","packages/react-resizable-panels/src/env-conditions/development.ts","packages/react-resizable-panels/src/PanelGroupContext.ts","packages/react-resizable-panels/src/vendor/react.ts","packages/react-resizable-panels/src/hooks/useIsomorphicEffect.ts","packages/react-resizable-panels/src/hooks/useUniqueId.ts","packages/react-resizable-panels/src/PanelGroup.ts","packages/react-resizable-panels/src/hooks/useWindowSplitterPanelGroupBehavior.ts","packages/react-resizable-panels/src/utils/adjustLayoutByDelta.ts","packages/react-resizable-panels/src/utils/computePercentagePanelConstraints.ts","packages/react-resizable-panels/src/utils/convertPixelConstraintsToPercentages.ts","packages/react-resizable-panels/src/utils/convertPixelsToPercentage.ts","packages/react-resizable-panels/src/utils/numbers/fuzzyCompareNumbers.ts","packages/react-resizable-panels/src/constants.ts","packages/react-resizable-panels/src/utils/numbers/fuzzyNumbersEqual.ts","packages/react-resizable-panels/src/utils/resizePanel.ts","packages/react-resizable-panels/src/utils/assert.ts","packages/react-resizable-panels/src/utils/calculateAriaValues.ts","packages/react-resizable-panels/src/utils/getPercentageSizeFromMixedSizes.ts","packages/react-resizable-panels/src/utils/determinePivotIndices.ts","packages/react-resizable-panels/src/utils/dom/getResizeHandleElementIndex.ts","packages/react-resizable-panels/src/utils/dom/getResizeHandleElementsForGroup.ts","packages/react-resizable-panels/src/utils/dom/calculateAvailablePanelSizeInPixels.ts","packages/react-resizable-panels/src/utils/dom/getPanelGroupElement.ts","packages/react-resizable-panels/src/utils/dom/getAvailableGroupSizePixels.ts","packages/react-resizable-panels/src/utils/dom/getResizeHandlePanelIds.ts","packages/react-resizable-panels/src/utils/dom/getResizeHandleElement.ts","packages/react-resizable-panels/src/utils/arrays.ts","packages/react-resizable-panels/src/utils/calculateDeltaPercentage.ts","packages/react-resizable-panels/src/utils/calculateDragOffsetPercentage.ts","packages/react-resizable-panels/src/utils/getResizeEventCursorPosition.ts","packages/react-resizable-panels/src/utils/events.ts","packages/react-resizable-panels/src/utils/calculateUnsafeDefaultLayout.ts","packages/react-resizable-panels/src/utils/callPanelCallbacks.ts","packages/react-resizable-panels/src/utils/convertPercentageToPixels.ts","packages/react-resizable-panels/src/utils/compareLayouts.ts","packages/react-resizable-panels/src/utils/computePanelFlexBoxStyle.ts","packages/react-resizable-panels/src/utils/cursor.ts","packages/react-resizable-panels/src/utils/debounce.ts","packages/react-resizable-panels/src/utils/dom/getPanelElementsForGroup.ts","packages/react-resizable-panels/src/utils/initializeDefaultStorage.ts","packages/react-resizable-panels/src/utils/serialization.ts","packages/react-resizable-panels/src/utils/shouldMonitorPixelBasedConstraints.ts","packages/react-resizable-panels/src/utils/validatePanelConstraints.ts","packages/react-resizable-panels/src/utils/validatePanelGroupLayout.ts","packages/react-resizable-panels/src/PanelResizeHandle.ts","packages/react-resizable-panels/src/hooks/useWindowSplitterBehavior.ts"],"sourcesContent":["import { Panel } from \"./Panel\";\nimport { PanelGroup } from \"./PanelGroup\";\nimport { PanelResizeHandle } from \"./PanelResizeHandle\";\n\nimport type { MixedSizes } from \"./types\";\n\nimport type {\n  ImperativePanelHandle,\n  PanelOnCollapse,\n  PanelOnExpand,\n  PanelOnResize,\n  PanelProps,\n} from \"./Panel\";\nimport type {\n  ImperativePanelGroupHandle,\n  PanelGroupOnLayout,\n  PanelGroupProps,\n  PanelGroupStorage,\n} from \"./PanelGroup\";\nimport type {\n  PanelResizeHandleOnDragging,\n  PanelResizeHandleProps,\n} from \"./PanelResizeHandle\";\n\nexport {\n  // TypeScript types\n  ImperativePanelGroupHandle,\n  ImperativePanelHandle,\n  MixedSizes,\n  PanelGroupOnLayout,\n  PanelGroupProps,\n  PanelGroupStorage,\n  PanelOnCollapse,\n  PanelOnExpand,\n  PanelOnResize,\n  PanelProps,\n  PanelResizeHandleOnDragging,\n  PanelResizeHandleProps,\n\n  // React components\n  Panel,\n  PanelGroup,\n  PanelResizeHandle,\n};\n","import { isBrowser } from \"#is-browser\";\nimport { isDevelopment } from \"#is-development\";\nimport { PanelGroupContext } from \"./PanelGroupContext\";\nimport useIsomorphicLayoutEffect from \"./hooks/useIsomorphicEffect\";\nimport useUniqueId from \"./hooks/useUniqueId\";\nimport { DataAttributes, MixedSizes } from \"./types\";\nimport {\n  ElementType,\n  ForwardedRef,\n  PropsWithChildren,\n  createElement,\n  forwardRef,\n  useContext,\n  useImperativeHandle,\n  useRef,\n} from \"./vendor/react\";\n\nexport type PanelOnCollapse = () => void;\nexport type PanelOnExpand = () => void;\nexport type PanelOnResize = (\n  mixedSizes: MixedSizes,\n  prevMixedSizes: MixedSizes | undefined\n) => void;\n\nexport type PanelCallbacks = {\n  onCollapse?: PanelOnCollapse;\n  onExpand?: PanelOnExpand;\n  onResize?: PanelOnResize;\n};\n\nexport type PanelConstraints = {\n  collapsedSizePercentage?: number | undefined;\n  collapsedSizePixels?: number | undefined;\n  collapsible?: boolean | undefined;\n  defaultSizePercentage?: number | undefined;\n  defaultSizePixels?: number | undefined;\n  maxSizePercentage?: number | undefined;\n  maxSizePixels?: number | undefined;\n  minSizePercentage?: number | undefined;\n  minSizePixels?: number | undefined;\n};\n\nexport type PanelData = {\n  callbacks: PanelCallbacks;\n  constraints: PanelConstraints;\n  id: string;\n  idIsFromProps: boolean;\n  order: number | undefined;\n};\n\nexport type ImperativePanelHandle = {\n  collapse: () => void;\n  expand: () => void;\n  getId(): string;\n  getSize(): MixedSizes;\n  isCollapsed: () => boolean;\n  isExpanded: () => boolean;\n  resize: (size: Partial<MixedSizes>) => void;\n};\n\nexport type PanelProps = PropsWithChildren<{\n  className?: string;\n  collapsedSizePercentage?: number | undefined;\n  collapsedSizePixels?: number | undefined;\n  collapsible?: boolean | undefined;\n  dataAttributes?: DataAttributes;\n  defaultSizePercentage?: number | undefined;\n  defaultSizePixels?: number | undefined;\n  id?: string;\n  maxSizePercentage?: number | undefined;\n  maxSizePixels?: number | undefined;\n  minSizePercentage?: number | undefined;\n  minSizePixels?: number | undefined;\n  onCollapse?: PanelOnCollapse;\n  onExpand?: PanelOnExpand;\n  onResize?: PanelOnResize;\n  order?: number;\n  style?: object;\n  tagName?: ElementType;\n}>;\n\nexport function PanelWithForwardedRef({\n  children,\n  className: classNameFromProps = \"\",\n  collapsedSizePercentage,\n  collapsedSizePixels,\n  collapsible,\n  dataAttributes,\n  defaultSizePercentage,\n  defaultSizePixels,\n  forwardedRef,\n  id: idFromProps,\n  maxSizePercentage,\n  maxSizePixels,\n  minSizePercentage,\n  minSizePixels,\n  onCollapse,\n  onExpand,\n  onResize,\n  order,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n}: PanelProps & {\n  forwardedRef: ForwardedRef<ImperativePanelHandle>;\n}) {\n  const context = useContext(PanelGroupContext);\n  if (context === null) {\n    throw Error(\n      `Panel components must be rendered within a PanelGroup container`\n    );\n  }\n\n  const {\n    collapsePanel,\n    expandPanel,\n    getPanelSize,\n    getPanelStyle,\n    groupId,\n    isPanelCollapsed,\n    registerPanel,\n    resizePanel,\n    unregisterPanel,\n  } = context;\n\n  const panelId = useUniqueId(idFromProps);\n\n  const panelDataRef = useRef<PanelData>({\n    callbacks: {\n      onCollapse,\n      onExpand,\n      onResize,\n    },\n    constraints: {\n      collapsedSizePercentage,\n      collapsedSizePixels,\n      collapsible,\n      defaultSizePercentage,\n      defaultSizePixels,\n      maxSizePercentage,\n      maxSizePixels,\n      minSizePercentage,\n      minSizePixels,\n    },\n    id: panelId,\n    idIsFromProps: idFromProps !== undefined,\n    order,\n  });\n\n  const devWarningsRef = useRef<{\n    didLogMissingDefaultSizeWarning: boolean;\n  }>({\n    didLogMissingDefaultSizeWarning: false,\n  });\n\n  // Normally we wouldn't log a warning during render,\n  // but effects don't run on the server, so we can't do it there\n  if (isDevelopment) {\n    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) {\n      if (\n        !isBrowser &&\n        defaultSizePercentage == null &&\n        defaultSizePixels == null\n      ) {\n        devWarningsRef.current.didLogMissingDefaultSizeWarning = true;\n        console.warn(\n          `WARNING: Panel defaultSizePercentage or defaultSizePixels prop recommended to avoid layout shift after server rendering`\n        );\n      }\n    }\n  }\n\n  useIsomorphicLayoutEffect(() => {\n    const { callbacks, constraints } = panelDataRef.current;\n\n    panelDataRef.current.id = panelId;\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\n    panelDataRef.current.order = order;\n\n    callbacks.onCollapse = onCollapse;\n    callbacks.onExpand = onExpand;\n    callbacks.onResize = onResize;\n\n    constraints.collapsedSizePercentage = collapsedSizePercentage;\n    constraints.collapsedSizePixels = collapsedSizePixels;\n    constraints.collapsible = collapsible;\n    constraints.defaultSizePercentage = defaultSizePercentage;\n    constraints.defaultSizePixels = defaultSizePixels;\n    constraints.maxSizePercentage = maxSizePercentage;\n    constraints.maxSizePixels = maxSizePixels;\n    constraints.minSizePercentage = minSizePercentage;\n    constraints.minSizePixels = minSizePixels;\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const panelData = panelDataRef.current;\n\n    registerPanel(panelData);\n\n    return () => {\n      unregisterPanel(panelData);\n    };\n  }, [order, panelId, registerPanel, unregisterPanel]);\n\n  useImperativeHandle(\n    forwardedRef,\n    () => ({\n      collapse: () => {\n        collapsePanel(panelDataRef.current);\n      },\n      expand: () => {\n        expandPanel(panelDataRef.current);\n      },\n      getId() {\n        return panelId;\n      },\n      getSize() {\n        return getPanelSize(panelDataRef.current);\n      },\n      isCollapsed() {\n        return isPanelCollapsed(panelDataRef.current);\n      },\n      isExpanded() {\n        return !isPanelCollapsed(panelDataRef.current);\n      },\n      resize: (mixedSizes: Partial<MixedSizes>) => {\n        resizePanel(panelDataRef.current, mixedSizes);\n      },\n    }),\n    [\n      collapsePanel,\n      expandPanel,\n      getPanelSize,\n      isPanelCollapsed,\n      panelId,\n      resizePanel,\n    ]\n  );\n\n  const style = getPanelStyle(panelDataRef.current);\n\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    style: {\n      ...style,\n      ...styleFromProps,\n    },\n\n    ...dataAttributes,\n\n    // CSS selectors\n    \"data-panel\": \"\",\n    \"data-panel-id\": panelId,\n    \"data-panel-group-id\": groupId,\n\n    // e2e test attributes\n    \"data-panel-collapsible\": isDevelopment\n      ? collapsible || undefined\n      : undefined,\n    \"data-panel-size\": isDevelopment\n      ? parseFloat(\"\" + style.flexGrow).toFixed(1)\n      : undefined,\n  });\n}\n\nexport const Panel = forwardRef<ImperativePanelHandle, PanelProps>(\n  (props: PanelProps, ref: ForwardedRef<ImperativePanelHandle>) =>\n    createElement(PanelWithForwardedRef, { ...props, forwardedRef: ref })\n);\n\nPanelWithForwardedRef.displayName = \"Panel\";\nPanel.displayName = \"forwardRef(Panel)\";\n","export const isBrowser = true;\n","export const isDevelopment = true;\n","import { PanelData } from \"./Panel\";\nimport { MixedSizes } from \"./types\";\nimport { CSSProperties, createContext } from \"./vendor/react\";\n\nexport type ResizeEvent = KeyboardEvent | MouseEvent | TouchEvent;\nexport type ResizeHandler = (event: ResizeEvent) => void;\n\nexport type DragState = {\n  dragHandleId: string;\n  dragHandleRect: DOMRect;\n  initialCursorPosition: number;\n  initialLayout: number[];\n};\n\nexport const PanelGroupContext = createContext<{\n  collapsePanel: (panelData: PanelData) => void;\n  direction: \"horizontal\" | \"vertical\";\n  dragState: DragState | null;\n  expandPanel: (panelData: PanelData) => void;\n  getPanelSize: (panelData: PanelData) => MixedSizes;\n  getPanelStyle: (panelData: PanelData) => CSSProperties;\n  groupId: string;\n  isPanelCollapsed: (panelData: PanelData) => boolean;\n  isPanelExpanded: (panelData: PanelData) => boolean;\n  registerPanel: (panelData: PanelData) => void;\n  registerResizeHandle: (dragHandleId: string) => ResizeHandler;\n  resizePanel: (panelData: PanelData, mixedSizes: Partial<MixedSizes>) => void;\n  startDragging: (dragHandleId: string, event: ResizeEvent) => void;\n  stopDragging: () => void;\n  unregisterPanel: (panelData: PanelData) => void;\n} | null>(null);\n\nPanelGroupContext.displayName = \"PanelGroupContext\";\n","// This module exists to work around Webpack issue https://github.com/webpack/webpack/issues/14814\n// and limitations with ParcelJS parsing of the useId workaround (used below).\n// For the time being, all react-resizable-panels must import \"react\" with the \"* as React\" syntax.\n// To avoid mistakes, we use the ESLint \"no-restricted-imports\" to prevent \"react\" imports except in this file.\n// See https://github.com/bvaughn/react-resizable-panels/issues/118\n\n// eslint-disable-next-line no-restricted-imports\nimport * as React from \"react\";\n\n// eslint-disable-next-line no-restricted-imports\nimport type {\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  MouseEvent,\n  PropsWithChildren,\n  ReactNode,\n  RefObject,\n  TouchEvent,\n} from \"react\";\n\nconst {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n} = React;\n\n// `toString()` prevents bundlers from trying to `import { useId } from 'react'`\nconst useId = (React as any)[\"useId\".toString()] as () => string;\n\nexport {\n  createElement,\n  createContext,\n  createRef,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useId,\n  useImperativeHandle,\n  useLayoutEffect,\n  useMemo,\n  useRef,\n  useState,\n};\n\nexport type {\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  MouseEvent,\n  PropsWithChildren,\n  ReactNode,\n  RefObject,\n  TouchEvent,\n};\n","import { isBrowser } from \"#is-browser\";\nimport { useLayoutEffect } from \"../vendor/react\";\n\nconst useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : () => {};\n\nexport default useIsomorphicLayoutEffect;\n","import { useId, useRef } from \"../vendor/react\";\n\nconst wrappedUseId: () => string | null =\n  typeof useId === \"function\" ? useId : (): null => null;\n\nlet counter = 0;\n\nexport default function useUniqueId(\n  idFromParams: string | null = null\n): string {\n  const idFromUseId = wrappedUseId();\n\n  const idRef = useRef<string | null>(idFromParams || idFromUseId || null);\n  if (idRef.current === null) {\n    idRef.current = \"\" + counter++;\n  }\n\n  return idFromParams ?? idRef.current;\n}\n","import { isDevelopment } from \"#is-development\";\nimport { PanelData } from \"./Panel\";\nimport { DragState, PanelGroupContext, ResizeEvent } from \"./PanelGroupContext\";\nimport useIsomorphicLayoutEffect from \"./hooks/useIsomorphicEffect\";\nimport useUniqueId from \"./hooks/useUniqueId\";\nimport { useWindowSplitterPanelGroupBehavior } from \"./hooks/useWindowSplitterPanelGroupBehavior\";\nimport { DataAttributes, Direction, MixedSizes } from \"./types\";\nimport { adjustLayoutByDelta } from \"./utils/adjustLayoutByDelta\";\nimport { areEqual } from \"./utils/arrays\";\nimport { calculateDeltaPercentage } from \"./utils/calculateDeltaPercentage\";\nimport { calculateUnsafeDefaultLayout } from \"./utils/calculateUnsafeDefaultLayout\";\nimport { callPanelCallbacks } from \"./utils/callPanelCallbacks\";\nimport { compareLayouts } from \"./utils/compareLayouts\";\nimport { computePanelFlexBoxStyle } from \"./utils/computePanelFlexBoxStyle\";\nimport { computePercentagePanelConstraints } from \"./utils/computePercentagePanelConstraints\";\nimport { convertPercentageToPixels } from \"./utils/convertPercentageToPixels\";\nimport { resetGlobalCursorStyle, setGlobalCursorStyle } from \"./utils/cursor\";\nimport debounce from \"./utils/debounce\";\nimport { determinePivotIndices } from \"./utils/determinePivotIndices\";\nimport { calculateAvailablePanelSizeInPixels } from \"./utils/dom/calculateAvailablePanelSizeInPixels\";\nimport { getPanelElementsForGroup } from \"./utils/dom/getPanelElementsForGroup\";\nimport { getPanelGroupElement } from \"./utils/dom/getPanelGroupElement\";\nimport { getResizeHandleElement } from \"./utils/dom/getResizeHandleElement\";\nimport { isKeyDown, isMouseEvent, isTouchEvent } from \"./utils/events\";\nimport { getPercentageSizeFromMixedSizes } from \"./utils/getPercentageSizeFromMixedSizes\";\nimport { getResizeEventCursorPosition } from \"./utils/getResizeEventCursorPosition\";\nimport { initializeDefaultStorage } from \"./utils/initializeDefaultStorage\";\nimport { loadPanelLayout, savePanelGroupLayout } from \"./utils/serialization\";\nimport { shouldMonitorPixelBasedConstraints } from \"./utils/shouldMonitorPixelBasedConstraints\";\nimport { validatePanelConstraints } from \"./utils/validatePanelConstraints\";\nimport { validatePanelGroupLayout } from \"./utils/validatePanelGroupLayout\";\nimport {\n  CSSProperties,\n  ElementType,\n  ForwardedRef,\n  PropsWithChildren,\n  createElement,\n  forwardRef,\n  useCallback,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useRef,\n  useState,\n} from \"./vendor/react\";\n\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\n\nexport type ImperativePanelGroupHandle = {\n  getId: () => string;\n  getLayout: () => MixedSizes[];\n  setLayout: (layout: Partial<MixedSizes>[]) => void;\n};\n\nexport type PanelGroupStorage = {\n  getItem(name: string): string | null;\n  setItem(name: string, value: string): void;\n};\n\nexport type PanelGroupOnLayout = (layout: MixedSizes[]) => void;\n\nconst defaultStorage: PanelGroupStorage = {\n  getItem: (name: string) => {\n    initializeDefaultStorage(defaultStorage);\n    return defaultStorage.getItem(name);\n  },\n  setItem: (name: string, value: string) => {\n    initializeDefaultStorage(defaultStorage);\n    defaultStorage.setItem(name, value);\n  },\n};\n\nexport type PanelGroupProps = PropsWithChildren<{\n  autoSaveId?: string | null;\n  className?: string;\n  dataAttributes?: DataAttributes;\n  direction: Direction;\n  id?: string | null;\n  keyboardResizeByPercentage?: number | null;\n  keyboardResizeByPixels?: number | null;\n  onLayout?: PanelGroupOnLayout | null;\n  storage?: PanelGroupStorage;\n  style?: CSSProperties;\n  tagName?: ElementType;\n}>;\n\nconst debounceMap: {\n  [key: string]: typeof savePanelGroupLayout;\n} = {};\n\nfunction PanelGroupWithForwardedRef({\n  autoSaveId = null,\n  children,\n  className: classNameFromProps = \"\",\n  dataAttributes,\n  direction,\n  forwardedRef,\n  id: idFromProps,\n  onLayout = null,\n  keyboardResizeByPercentage = null,\n  keyboardResizeByPixels = null,\n  storage = defaultStorage,\n  style: styleFromProps,\n  tagName: Type = \"div\",\n}: PanelGroupProps & {\n  forwardedRef: ForwardedRef<ImperativePanelGroupHandle>;\n}) {\n  const groupId = useUniqueId(idFromProps);\n\n  const [dragState, setDragState] = useState<DragState | null>(null);\n  const [layout, setLayout] = useState<number[]>([]);\n\n  const panelIdToLastNotifiedMixedSizesMapRef = useRef<\n    Record<string, MixedSizes>\n  >({});\n  const panelSizeBeforeCollapseRef = useRef<Map<string, number>>(new Map());\n  const prevDeltaRef = useRef<number>(0);\n\n  const committedValuesRef = useRef<{\n    autoSaveId: string | null;\n    direction: Direction;\n    dragState: DragState | null;\n    id: string;\n    keyboardResizeByPercentage: number | null;\n    keyboardResizeByPixels: number | null;\n    onLayout: PanelGroupOnLayout | null;\n    storage: PanelGroupStorage;\n  }>({\n    autoSaveId,\n    direction,\n    dragState,\n    id: groupId,\n    keyboardResizeByPercentage,\n    keyboardResizeByPixels,\n    onLayout,\n    storage,\n  });\n\n  const eagerValuesRef = useRef<{\n    layout: number[];\n    panelDataArray: PanelData[];\n  }>({\n    layout,\n    panelDataArray: [],\n  });\n\n  const devWarningsRef = useRef<{\n    didLogIdAndOrderWarning: boolean;\n    didLogPanelConstraintsWarning: boolean;\n    prevPanelIds: string[];\n  }>({\n    didLogIdAndOrderWarning: false,\n    didLogPanelConstraintsWarning: false,\n    prevPanelIds: [],\n  });\n\n  useImperativeHandle(\n    forwardedRef,\n    () => ({\n      getId: () => committedValuesRef.current.id,\n      getLayout: () => {\n        const { id: groupId } = committedValuesRef.current;\n        const { layout } = eagerValuesRef.current;\n\n        const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n        return layout.map((sizePercentage) => {\n          return {\n            sizePercentage,\n            sizePixels: convertPercentageToPixels(\n              sizePercentage,\n              groupSizePixels\n            ),\n          };\n        });\n      },\n      setLayout: (mixedSizes: Partial<MixedSizes>[]) => {\n        const { id: groupId, onLayout } = committedValuesRef.current;\n        const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n        const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n        const unsafeLayout = mixedSizes.map(\n          (mixedSize) =>\n            getPercentageSizeFromMixedSizes(mixedSize, groupSizePixels)!\n        );\n\n        const safeLayout = validatePanelGroupLayout({\n          groupSizePixels,\n          layout: unsafeLayout,\n          panelConstraints: panelDataArray.map(\n            (panelData) => panelData.constraints\n          ),\n        });\n\n        if (!areEqual(prevLayout, safeLayout)) {\n          setLayout(safeLayout);\n\n          eagerValuesRef.current.layout = safeLayout;\n\n          if (onLayout) {\n            onLayout(\n              safeLayout.map((sizePercentage) => ({\n                sizePercentage,\n                sizePixels: convertPercentageToPixels(\n                  sizePercentage,\n                  groupSizePixels\n                ),\n              }))\n            );\n          }\n\n          callPanelCallbacks(\n            groupId,\n            panelDataArray,\n            safeLayout,\n            panelIdToLastNotifiedMixedSizesMapRef.current\n          );\n        }\n      },\n    }),\n    []\n  );\n\n  useIsomorphicLayoutEffect(() => {\n    committedValuesRef.current.autoSaveId = autoSaveId;\n    committedValuesRef.current.direction = direction;\n    committedValuesRef.current.dragState = dragState;\n    committedValuesRef.current.id = groupId;\n    committedValuesRef.current.onLayout = onLayout;\n    committedValuesRef.current.storage = storage;\n\n    // panelDataArray and layout are updated in-sync with scheduled state updates.\n    // TODO [217] Move these values into a separate ref\n  });\n\n  useWindowSplitterPanelGroupBehavior({\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray: eagerValuesRef.current.panelDataArray,\n    setLayout,\n  });\n\n  useEffect(() => {\n    const { panelDataArray } = eagerValuesRef.current;\n\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\n    if (autoSaveId) {\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\n        return;\n      }\n\n      // Limit the frequency of localStorage updates.\n      if (!debounceMap[autoSaveId]) {\n        debounceMap[autoSaveId] = debounce(\n          savePanelGroupLayout,\n          LOCAL_STORAGE_DEBOUNCE_INTERVAL\n        );\n      }\n      debounceMap[autoSaveId](autoSaveId, panelDataArray, layout, storage);\n    }\n  }, [autoSaveId, layout, storage]);\n\n  useIsomorphicLayoutEffect(() => {\n    const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n    const constraints = panelDataArray.map(({ constraints }) => constraints);\n    if (!shouldMonitorPixelBasedConstraints(constraints)) {\n      // Avoid the overhead of ResizeObserver if no pixel constraints require monitoring\n      return;\n    }\n\n    if (typeof ResizeObserver === \"undefined\") {\n      console.warn(\n        `WARNING: Pixel based constraints require ResizeObserver but it is not supported by the current browser.`\n      );\n    } else {\n      const resizeObserver = new ResizeObserver(() => {\n        const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n        const { onLayout } = committedValuesRef.current;\n\n        const nextLayout = validatePanelGroupLayout({\n          groupSizePixels,\n          layout: prevLayout,\n          panelConstraints: panelDataArray.map(\n            (panelData) => panelData.constraints\n          ),\n        });\n\n        if (!areEqual(prevLayout, nextLayout)) {\n          setLayout(nextLayout);\n\n          eagerValuesRef.current.layout = nextLayout;\n\n          if (onLayout) {\n            onLayout(\n              nextLayout.map((sizePercentage) => ({\n                sizePercentage,\n                sizePixels: convertPercentageToPixels(\n                  sizePercentage,\n                  groupSizePixels\n                ),\n              }))\n            );\n          }\n\n          callPanelCallbacks(\n            groupId,\n            panelDataArray,\n            nextLayout,\n            panelIdToLastNotifiedMixedSizesMapRef.current\n          );\n        }\n      });\n\n      resizeObserver.observe(getPanelGroupElement(groupId)!);\n\n      return () => {\n        resizeObserver.disconnect();\n      };\n    }\n  }, [groupId]);\n\n  // DEV warnings\n  useEffect(() => {\n    if (isDevelopment) {\n      const { panelDataArray } = eagerValuesRef.current;\n\n      const {\n        didLogIdAndOrderWarning,\n        didLogPanelConstraintsWarning,\n        prevPanelIds,\n      } = devWarningsRef.current;\n\n      if (!didLogIdAndOrderWarning) {\n        const panelIds = panelDataArray.map(({ id }) => id);\n\n        devWarningsRef.current.prevPanelIds = panelIds;\n\n        const panelsHaveChanged =\n          prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\n        if (panelsHaveChanged) {\n          if (\n            panelDataArray.find(\n              ({ idIsFromProps, order }) => !idIsFromProps || order == null\n            )\n          ) {\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\n\n            console.warn(\n              `WARNING: Panel id and order props recommended when panels are dynamically rendered`\n            );\n          }\n        }\n      }\n\n      if (!didLogPanelConstraintsWarning) {\n        const panelConstraints = panelDataArray.map(\n          (panelData) => panelData.constraints\n        );\n\n        const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n        for (\n          let panelIndex = 0;\n          panelIndex < panelConstraints.length;\n          panelIndex++\n        ) {\n          const isValid = validatePanelConstraints({\n            groupSizePixels,\n            panelConstraints,\n            panelId: panelDataArray[panelIndex].id,\n            panelIndex,\n          });\n\n          if (!isValid) {\n            devWarningsRef.current.didLogPanelConstraintsWarning = true;\n\n            break;\n          }\n        }\n      }\n    }\n  });\n\n  // External APIs are safe to memoize via committed values ref\n  const collapsePanel = useCallback(\n    (panelData: PanelData) => {\n      const { onLayout } = committedValuesRef.current;\n      const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n      if (panelData.constraints.collapsible) {\n        const panelConstraintsArray = panelDataArray.map(\n          (panelData) => panelData.constraints\n        );\n\n        const {\n          collapsedSizePercentage,\n          panelSizePercentage,\n          pivotIndices,\n          groupSizePixels,\n        } = panelDataHelper(groupId, panelDataArray, panelData, prevLayout);\n\n        if (panelSizePercentage !== collapsedSizePercentage) {\n          // Store size before collapse;\n          // This is the size that gets restored if the expand() API is used.\n          panelSizeBeforeCollapseRef.current.set(\n            panelData.id,\n            panelSizePercentage\n          );\n\n          const isLastPanel =\n            panelDataArray.indexOf(panelData) === panelDataArray.length - 1;\n          const delta = isLastPanel\n            ? panelSizePercentage - collapsedSizePercentage\n            : collapsedSizePercentage - panelSizePercentage;\n\n          const nextLayout = adjustLayoutByDelta({\n            delta,\n            groupSizePixels,\n            layout: prevLayout,\n            panelConstraints: panelConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n          });\n\n          if (!compareLayouts(prevLayout, nextLayout)) {\n            setLayout(nextLayout);\n\n            eagerValuesRef.current.layout = nextLayout;\n\n            if (onLayout) {\n              onLayout(\n                nextLayout.map((sizePercentage) => ({\n                  sizePercentage,\n                  sizePixels: convertPercentageToPixels(\n                    sizePercentage,\n                    groupSizePixels\n                  ),\n                }))\n              );\n            }\n\n            callPanelCallbacks(\n              groupId,\n              panelDataArray,\n              nextLayout,\n              panelIdToLastNotifiedMixedSizesMapRef.current\n            );\n          }\n        }\n      }\n    },\n    [groupId]\n  );\n\n  // External APIs are safe to memoize via committed values ref\n  const expandPanel = useCallback(\n    (panelData: PanelData) => {\n      const { onLayout } = committedValuesRef.current;\n      const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n      if (panelData.constraints.collapsible) {\n        const panelConstraintsArray = panelDataArray.map(\n          (panelData) => panelData.constraints\n        );\n\n        const {\n          collapsedSizePercentage,\n          panelSizePercentage,\n          minSizePercentage,\n          pivotIndices,\n          groupSizePixels,\n        } = panelDataHelper(groupId, panelDataArray, panelData, prevLayout);\n\n        if (panelSizePercentage === collapsedSizePercentage) {\n          // Restore this panel to the size it was before it was collapsed, if possible.\n          const prevPanelSizePercentage =\n            panelSizeBeforeCollapseRef.current.get(panelData.id);\n\n          const baseSizePercentage =\n            prevPanelSizePercentage != null &&\n            prevPanelSizePercentage >= minSizePercentage\n              ? prevPanelSizePercentage\n              : minSizePercentage;\n\n          const isLastPanel =\n            panelDataArray.indexOf(panelData) === panelDataArray.length - 1;\n          const delta = isLastPanel\n            ? panelSizePercentage - baseSizePercentage\n            : baseSizePercentage - panelSizePercentage;\n\n          const nextLayout = adjustLayoutByDelta({\n            delta,\n            groupSizePixels,\n            layout: prevLayout,\n            panelConstraints: panelConstraintsArray,\n            pivotIndices,\n            trigger: \"imperative-api\",\n          });\n\n          if (!compareLayouts(prevLayout, nextLayout)) {\n            setLayout(nextLayout);\n\n            eagerValuesRef.current.layout = nextLayout;\n\n            if (onLayout) {\n              onLayout(\n                nextLayout.map((sizePercentage) => ({\n                  sizePercentage,\n                  sizePixels: convertPercentageToPixels(\n                    sizePercentage,\n                    groupSizePixels\n                  ),\n                }))\n              );\n            }\n\n            callPanelCallbacks(\n              groupId,\n              panelDataArray,\n              nextLayout,\n              panelIdToLastNotifiedMixedSizesMapRef.current\n            );\n          }\n        }\n      }\n    },\n    [groupId]\n  );\n\n  // External APIs are safe to memoize via committed values ref\n  const getPanelSize = useCallback(\n    (panelData: PanelData) => {\n      const { layout, panelDataArray } = eagerValuesRef.current;\n\n      const { panelSizePercentage, panelSizePixels } = panelDataHelper(\n        groupId,\n        panelDataArray,\n        panelData,\n        layout\n      );\n\n      return {\n        sizePercentage: panelSizePercentage,\n        sizePixels: panelSizePixels,\n      };\n    },\n    [groupId]\n  );\n\n  // This API should never read from committedValuesRef\n  const getPanelStyle = useCallback(\n    (panelData: PanelData) => {\n      const { panelDataArray } = eagerValuesRef.current;\n\n      const panelIndex = panelDataArray.indexOf(panelData);\n\n      return computePanelFlexBoxStyle({\n        dragState,\n        layout,\n        panelData: panelDataArray,\n        panelIndex,\n      });\n    },\n    [dragState, layout]\n  );\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelCollapsed = useCallback(\n    (panelData: PanelData) => {\n      const { layout, panelDataArray } = eagerValuesRef.current;\n\n      const { collapsedSizePercentage, collapsible, panelSizePercentage } =\n        panelDataHelper(groupId, panelDataArray, panelData, layout);\n\n      return (\n        collapsible === true && panelSizePercentage === collapsedSizePercentage\n      );\n    },\n    [groupId]\n  );\n\n  // External APIs are safe to memoize via committed values ref\n  const isPanelExpanded = useCallback(\n    (panelData: PanelData) => {\n      const { layout, panelDataArray } = eagerValuesRef.current;\n\n      const { collapsedSizePercentage, collapsible, panelSizePercentage } =\n        panelDataHelper(groupId, panelDataArray, panelData, layout);\n\n      return !collapsible || panelSizePercentage > collapsedSizePercentage;\n    },\n    [groupId]\n  );\n\n  const registerPanel = useCallback((panelData: PanelData) => {\n    const {\n      autoSaveId,\n      id: groupId,\n      onLayout,\n      storage,\n    } = committedValuesRef.current;\n    const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n    panelDataArray.push(panelData);\n    panelDataArray.sort((panelA, panelB) => {\n      const orderA = panelA.order;\n      const orderB = panelB.order;\n      if (orderA == null && orderB == null) {\n        return 0;\n      } else if (orderA == null) {\n        return -1;\n      } else if (orderB == null) {\n        return 1;\n      } else {\n        return orderA - orderB;\n      }\n    });\n\n    // Wait until all panels have registered before we try to compute layout;\n    // doing it earlier is both wasteful and may trigger misleading warnings in development mode.\n    const panelElements = getPanelElementsForGroup(groupId);\n    if (panelElements.length !== panelDataArray.length) {\n      return;\n    }\n\n    // If this panel has been configured to persist sizing information,\n    // default size should be restored from local storage if possible.\n    let unsafeLayout: number[] | null = null;\n    if (autoSaveId) {\n      unsafeLayout = loadPanelLayout(autoSaveId, panelDataArray, storage);\n    }\n\n    const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n    if (groupSizePixels <= 0) {\n      if (\n        shouldMonitorPixelBasedConstraints(\n          panelDataArray.map(({ constraints }) => constraints)\n        )\n      ) {\n        // Wait until the group has rendered a non-zero size before computing layout.\n        return;\n      }\n    }\n\n    if (unsafeLayout == null) {\n      unsafeLayout = calculateUnsafeDefaultLayout({\n        groupSizePixels,\n        panelDataArray,\n      });\n    }\n\n    // Validate even saved layouts in case something has changed since last render\n    // e.g. for pixel groups, this could be the size of the window\n    const nextLayout = validatePanelGroupLayout({\n      groupSizePixels,\n      layout: unsafeLayout,\n      panelConstraints: panelDataArray.map(\n        (panelData) => panelData.constraints\n      ),\n    });\n\n    // Offscreen mode makes this a bit weird;\n    // Panels unregister when hidden and re-register when shown again,\n    // but the overall layout doesn't change between these two cases.\n    setLayout(nextLayout);\n\n    eagerValuesRef.current.layout = nextLayout;\n\n    if (!areEqual(prevLayout, nextLayout)) {\n      if (onLayout) {\n        onLayout(\n          nextLayout.map((sizePercentage) => ({\n            sizePercentage,\n            sizePixels: convertPercentageToPixels(\n              sizePercentage,\n              groupSizePixels\n            ),\n          }))\n        );\n      }\n\n      callPanelCallbacks(\n        groupId,\n        panelDataArray,\n        nextLayout,\n        panelIdToLastNotifiedMixedSizesMapRef.current\n      );\n    }\n  }, []);\n\n  const registerResizeHandle = useCallback((dragHandleId: string) => {\n    return function resizeHandler(event: ResizeEvent) {\n      event.preventDefault();\n\n      const {\n        direction,\n        dragState,\n        id: groupId,\n        keyboardResizeByPercentage,\n        keyboardResizeByPixels,\n        onLayout,\n      } = committedValuesRef.current;\n      const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n      const { initialLayout } = dragState ?? {};\n\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId);\n\n      let delta = calculateDeltaPercentage(\n        event,\n        groupId,\n        dragHandleId,\n        direction,\n        dragState!,\n        {\n          percentage: keyboardResizeByPercentage,\n          pixels: keyboardResizeByPixels,\n        }\n      );\n      if (delta === 0) {\n        return;\n      }\n\n      // Support RTL layouts\n      const isHorizontal = direction === \"horizontal\";\n      if (document.dir === \"rtl\" && isHorizontal) {\n        delta = -delta;\n      }\n\n      const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n      const panelConstraints = panelDataArray.map(\n        (panelData) => panelData.constraints\n      );\n\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        groupSizePixels,\n        layout: initialLayout ?? prevLayout,\n        panelConstraints,\n        pivotIndices,\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\",\n      });\n\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\n\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\n      if (isMouseEvent(event) || isTouchEvent(event)) {\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\n        // In this case, Panel sizes might not change\n        // but updating cursor in this scenario would cause a flicker.\n        if (prevDeltaRef.current != delta) {\n          prevDeltaRef.current = delta;\n\n          if (!layoutChanged) {\n            // If the pointer has moved too far to resize the panel any further,\n            // update the cursor style for a visual clue.\n            // This mimics VS Code behavior.\n\n            if (isHorizontal) {\n              setGlobalCursorStyle(\n                delta < 0 ? \"horizontal-min\" : \"horizontal-max\"\n              );\n            } else {\n              setGlobalCursorStyle(delta < 0 ? \"vertical-min\" : \"vertical-max\");\n            }\n          } else {\n            // Reset the cursor style to the the normal resize cursor.\n            setGlobalCursorStyle(isHorizontal ? \"horizontal\" : \"vertical\");\n          }\n        }\n      }\n\n      if (layoutChanged) {\n        setLayout(nextLayout);\n\n        eagerValuesRef.current.layout = nextLayout;\n\n        if (onLayout) {\n          onLayout(\n            nextLayout.map((sizePercentage) => ({\n              sizePercentage,\n              sizePixels: convertPercentageToPixels(\n                sizePercentage,\n                groupSizePixels\n              ),\n            }))\n          );\n        }\n\n        callPanelCallbacks(\n          groupId,\n          panelDataArray,\n          nextLayout,\n          panelIdToLastNotifiedMixedSizesMapRef.current\n        );\n      }\n    };\n  }, []);\n\n  // External APIs are safe to memoize via committed values ref\n  const resizePanel = useCallback(\n    (panelData: PanelData, mixedSizes: Partial<MixedSizes>) => {\n      const { onLayout } = committedValuesRef.current;\n\n      const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n      const panelConstraintsArray = panelDataArray.map(\n        (panelData) => panelData.constraints\n      );\n\n      const { groupSizePixels, panelSizePercentage, pivotIndices } =\n        panelDataHelper(groupId, panelDataArray, panelData, prevLayout);\n\n      const sizePercentage = getPercentageSizeFromMixedSizes(\n        mixedSizes,\n        groupSizePixels\n      )!;\n\n      const isLastPanel =\n        panelDataArray.indexOf(panelData) === panelDataArray.length - 1;\n      const delta = isLastPanel\n        ? panelSizePercentage - sizePercentage\n        : sizePercentage - panelSizePercentage;\n\n      const nextLayout = adjustLayoutByDelta({\n        delta,\n        groupSizePixels,\n        layout: prevLayout,\n        panelConstraints: panelConstraintsArray,\n        pivotIndices,\n        trigger: \"imperative-api\",\n      });\n\n      if (!compareLayouts(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n\n        eagerValuesRef.current.layout = nextLayout;\n\n        if (onLayout) {\n          onLayout(\n            nextLayout.map((sizePercentage) => ({\n              sizePercentage,\n              sizePixels: convertPercentageToPixels(\n                sizePercentage,\n                groupSizePixels\n              ),\n            }))\n          );\n        }\n\n        callPanelCallbacks(\n          groupId,\n          panelDataArray,\n          nextLayout,\n          panelIdToLastNotifiedMixedSizesMapRef.current\n        );\n      }\n    },\n    [groupId]\n  );\n\n  const startDragging = useCallback(\n    (dragHandleId: string, event: ResizeEvent) => {\n      const { direction } = committedValuesRef.current;\n      const { layout } = eagerValuesRef.current;\n\n      const handleElement = getResizeHandleElement(dragHandleId)!;\n\n      const initialCursorPosition = getResizeEventCursorPosition(\n        direction,\n        event\n      );\n\n      setDragState({\n        dragHandleId,\n        dragHandleRect: handleElement.getBoundingClientRect(),\n        initialCursorPosition,\n        initialLayout: layout,\n      });\n    },\n    []\n  );\n\n  const stopDragging = useCallback(() => {\n    resetGlobalCursorStyle();\n    setDragState(null);\n  }, []);\n\n  const unregisterPanelRef = useRef<{\n    pendingPanelIds: Set<string>;\n    timeout: NodeJS.Timeout | null;\n  }>({\n    pendingPanelIds: new Set(),\n    timeout: null,\n  });\n  const unregisterPanel = useCallback((panelData: PanelData) => {\n    const { id: groupId, onLayout } = committedValuesRef.current;\n    const { layout: prevLayout, panelDataArray } = eagerValuesRef.current;\n\n    const index = panelDataArray.indexOf(panelData);\n    if (index >= 0) {\n      panelDataArray.splice(index, 1);\n      unregisterPanelRef.current.pendingPanelIds.add(panelData.id);\n    }\n\n    if (unregisterPanelRef.current.timeout != null) {\n      clearTimeout(unregisterPanelRef.current.timeout);\n    }\n\n    // Batch panel unmounts so that we only calculate layout once;\n    // This is more efficient and avoids misleading warnings in development mode.\n    // We can't check the DOM to detect this because Panel elements have not yet been removed.\n    unregisterPanelRef.current.timeout = setTimeout(() => {\n      const { pendingPanelIds } = unregisterPanelRef.current;\n      const map = panelIdToLastNotifiedMixedSizesMapRef.current;\n\n      // TRICKY\n      // Strict effects mode\n      let unmountDueToStrictMode = false;\n      pendingPanelIds.forEach((panelId) => {\n        pendingPanelIds.delete(panelId);\n\n        if (panelDataArray.find(({ id }) => id === panelId) == null) {\n          unmountDueToStrictMode = true;\n\n          // TRICKY\n          // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\n          // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\n          // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\n          delete map[panelData.id];\n        }\n      });\n\n      if (!unmountDueToStrictMode) {\n        return;\n      }\n\n      if (panelDataArray.length === 0) {\n        // The group is unmounting; skip layout calculation.\n        return;\n      }\n\n      const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n      let unsafeLayout: number[] = calculateUnsafeDefaultLayout({\n        groupSizePixels,\n        panelDataArray,\n      });\n\n      // Validate even saved layouts in case something has changed since last render\n      // e.g. for pixel groups, this could be the size of the window\n      const nextLayout = validatePanelGroupLayout({\n        groupSizePixels,\n        layout: unsafeLayout,\n        panelConstraints: panelDataArray.map(\n          (panelData) => panelData.constraints\n        ),\n      });\n\n      if (!areEqual(prevLayout, nextLayout)) {\n        setLayout(nextLayout);\n\n        eagerValuesRef.current.layout = nextLayout;\n\n        if (onLayout) {\n          onLayout(\n            nextLayout.map((sizePercentage) => ({\n              sizePercentage,\n              sizePixels: convertPercentageToPixels(\n                sizePercentage,\n                groupSizePixels\n              ),\n            }))\n          );\n        }\n\n        callPanelCallbacks(\n          groupId,\n          panelDataArray,\n          nextLayout,\n          panelIdToLastNotifiedMixedSizesMapRef.current\n        );\n      }\n    }, 0);\n  }, []);\n\n  const context = useMemo(\n    () => ({\n      collapsePanel,\n      direction,\n      dragState,\n      expandPanel,\n      getPanelSize,\n      getPanelStyle,\n      groupId,\n      isPanelCollapsed,\n      isPanelExpanded,\n      registerPanel,\n      registerResizeHandle,\n      resizePanel,\n      startDragging,\n      stopDragging,\n      unregisterPanel,\n    }),\n    [\n      collapsePanel,\n      dragState,\n      direction,\n      expandPanel,\n      getPanelSize,\n      getPanelStyle,\n      groupId,\n      isPanelCollapsed,\n      isPanelExpanded,\n      registerPanel,\n      registerResizeHandle,\n      resizePanel,\n      startDragging,\n      stopDragging,\n      unregisterPanel,\n    ]\n  );\n\n  const style: CSSProperties = {\n    display: \"flex\",\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\n    height: \"100%\",\n    overflow: \"hidden\",\n    width: \"100%\",\n  };\n\n  return createElement(\n    PanelGroupContext.Provider,\n    { value: context },\n    createElement(Type, {\n      children,\n      className: classNameFromProps,\n      style: {\n        ...style,\n        ...styleFromProps,\n      },\n\n      ...dataAttributes,\n\n      // CSS selectors\n      \"data-panel-group\": \"\",\n      \"data-panel-group-direction\": direction,\n      \"data-panel-group-id\": groupId,\n    })\n  );\n}\n\nexport const PanelGroup = forwardRef<\n  ImperativePanelGroupHandle,\n  PanelGroupProps\n>((props: PanelGroupProps, ref: ForwardedRef<ImperativePanelGroupHandle>) =>\n  createElement(PanelGroupWithForwardedRef, { ...props, forwardedRef: ref })\n);\n\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\n\nfunction panelDataHelper(\n  groupId: string,\n  panelDataArray: PanelData[],\n  panelData: PanelData,\n  layout: number[]\n) {\n  const panelConstraintsArray = panelDataArray.map(\n    (panelData) => panelData.constraints\n  );\n\n  const panelIndex = panelDataArray.indexOf(panelData);\n  const panelConstraints = panelConstraintsArray[panelIndex];\n\n  const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n  const percentagePanelConstraints = computePercentagePanelConstraints(\n    panelConstraintsArray,\n    panelIndex,\n    groupSizePixels\n  );\n\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\n  const pivotIndices = isLastPanel\n    ? [panelIndex - 1, panelIndex]\n    : [panelIndex, panelIndex + 1];\n\n  const panelSizePercentage = layout[panelIndex];\n  const panelSizePixels = convertPercentageToPixels(\n    panelSizePercentage,\n    groupSizePixels\n  );\n\n  return {\n    ...percentagePanelConstraints,\n    collapsible: panelConstraints.collapsible,\n    panelSizePercentage,\n    panelSizePixels,\n    groupSizePixels,\n    pivotIndices,\n  };\n}\n","import { isDevelopment } from \"#is-development\";\nimport { PanelData } from \"../Panel\";\nimport { Direction } from \"../types\";\nimport { adjustLayoutByDelta } from \"../utils/adjustLayoutByDelta\";\nimport { assert } from \"../utils/assert\";\nimport { calculateAriaValues } from \"../utils/calculateAriaValues\";\nimport { determinePivotIndices } from \"../utils/determinePivotIndices\";\nimport { calculateAvailablePanelSizeInPixels } from \"../utils/dom/calculateAvailablePanelSizeInPixels\";\nimport { getAvailableGroupSizePixels } from \"../utils/dom/getAvailableGroupSizePixels\";\nimport { getPanelGroupElement } from \"../utils/dom/getPanelGroupElement\";\nimport { getResizeHandleElementsForGroup } from \"../utils/dom/getResizeHandleElementsForGroup\";\nimport { getResizeHandlePanelIds } from \"../utils/dom/getResizeHandlePanelIds\";\nimport { getPercentageSizeFromMixedSizes } from \"../utils/getPercentageSizeFromMixedSizes\";\nimport { fuzzyNumbersEqual } from \"../utils/numbers/fuzzyNumbersEqual\";\nimport { RefObject, useEffect, useRef } from \"../vendor/react\";\nimport useIsomorphicLayoutEffect from \"./useIsomorphicEffect\";\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nexport function useWindowSplitterPanelGroupBehavior({\n  committedValuesRef,\n  eagerValuesRef,\n  groupId,\n  layout,\n  panelDataArray,\n  setLayout,\n}: {\n  committedValuesRef: RefObject<{\n    direction: Direction;\n  }>;\n  eagerValuesRef: RefObject<{\n    panelDataArray: PanelData[];\n  }>;\n  groupId: string;\n  layout: number[];\n  panelDataArray: PanelData[];\n  setLayout: (sizes: number[]) => void;\n}): void {\n  const devWarningsRef = useRef<{\n    didWarnAboutMissingResizeHandle: boolean;\n  }>({\n    didWarnAboutMissingResizeHandle: false,\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId);\n\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\n      const { valueMax, valueMin, valueNow } = calculateAriaValues({\n        groupSizePixels,\n        layout,\n        panelsArray: panelDataArray,\n        pivotIndices: [index, index + 1],\n      });\n\n      const resizeHandleElement = resizeHandleElements[index];\n      if (resizeHandleElement == null) {\n        if (isDevelopment) {\n          const { didWarnAboutMissingResizeHandle } = devWarningsRef.current;\n\n          if (!didWarnAboutMissingResizeHandle) {\n            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;\n\n            console.warn(\n              `WARNING: Missing resize handle for PanelGroup \"${groupId}\"`\n            );\n          }\n        }\n      } else {\n        resizeHandleElement.setAttribute(\n          \"aria-controls\",\n          panelDataArray[index].id\n        );\n        resizeHandleElement.setAttribute(\n          \"aria-valuemax\",\n          \"\" + Math.round(valueMax)\n        );\n        resizeHandleElement.setAttribute(\n          \"aria-valuemin\",\n          \"\" + Math.round(valueMin)\n        );\n        resizeHandleElement.setAttribute(\n          \"aria-valuenow\",\n          \"\" + Math.round(valueNow)\n        );\n      }\n    }\n\n    return () => {\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\n        resizeHandleElement.removeAttribute(\"aria-controls\");\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\n      });\n    };\n  }, [groupId, layout, panelDataArray]);\n\n  useEffect(() => {\n    const { panelDataArray } = eagerValuesRef.current!;\n\n    const groupElement = getPanelGroupElement(groupId);\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\n\n    const handles = getResizeHandleElementsForGroup(groupId);\n    const cleanupFunctions = handles.map((handle) => {\n      const handleId = handle.getAttribute(\"data-panel-resize-handle-id\")!;\n\n      const [idBefore, idAfter] = getResizeHandlePanelIds(\n        groupId,\n        handleId,\n        panelDataArray\n      );\n      if (idBefore == null || idAfter == null) {\n        return () => {};\n      }\n\n      const onKeyDown = (event: KeyboardEvent) => {\n        if (event.defaultPrevented) {\n          return;\n        }\n\n        switch (event.key) {\n          case \"Enter\": {\n            event.preventDefault();\n\n            const index = panelDataArray.findIndex(\n              (panelData) => panelData.id === idBefore\n            );\n            if (index >= 0) {\n              const panelData = panelDataArray[index];\n              const size = layout[index];\n              if (size != null && panelData.constraints.collapsible) {\n                const groupSizePixels = getAvailableGroupSizePixels(groupId);\n\n                const collapsedSize =\n                  getPercentageSizeFromMixedSizes(\n                    {\n                      sizePercentage:\n                        panelData.constraints.collapsedSizePercentage,\n                      sizePixels: panelData.constraints.collapsedSizePixels,\n                    },\n                    groupSizePixels\n                  ) ?? 0;\n                const minSize =\n                  getPercentageSizeFromMixedSizes(\n                    {\n                      sizePercentage: panelData.constraints.minSizePercentage,\n                      sizePixels: panelData.constraints.minSizePixels,\n                    },\n                    groupSizePixels\n                  ) ?? 0;\n\n                const nextLayout = adjustLayoutByDelta({\n                  delta: fuzzyNumbersEqual(size, collapsedSize)\n                    ? minSize - collapsedSize\n                    : collapsedSize - size,\n                  groupSizePixels,\n                  layout,\n                  panelConstraints: panelDataArray.map(\n                    (panelData) => panelData.constraints\n                  ),\n                  pivotIndices: determinePivotIndices(groupId, handleId),\n                  trigger: \"keyboard\",\n                });\n                if (layout !== nextLayout) {\n                  setLayout(nextLayout);\n                }\n              }\n            }\n            break;\n          }\n        }\n      };\n\n      handle.addEventListener(\"keydown\", onKeyDown);\n\n      return () => {\n        handle.removeEventListener(\"keydown\", onKeyDown);\n      };\n    });\n\n    return () => {\n      cleanupFunctions.forEach((cleanupFunction) => cleanupFunction());\n    };\n  }, [\n    committedValuesRef,\n    eagerValuesRef,\n    groupId,\n    layout,\n    panelDataArray,\n    setLayout,\n  ]);\n}\n","import { PanelConstraints } from \"../Panel\";\nimport { computePercentagePanelConstraints } from \"./computePercentagePanelConstraints\";\nimport { fuzzyCompareNumbers } from \"./numbers/fuzzyCompareNumbers\";\nimport { fuzzyNumbersEqual } from \"./numbers/fuzzyNumbersEqual\";\nimport { resizePanel } from \"./resizePanel\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function adjustLayoutByDelta({\n  delta,\n  groupSizePixels,\n  layout: prevLayout,\n  panelConstraints,\n  pivotIndices,\n  trigger,\n}: {\n  delta: number;\n  groupSizePixels: number;\n  layout: number[];\n  panelConstraints: PanelConstraints[];\n  pivotIndices: number[];\n  trigger: \"imperative-api\" | \"keyboard\" | \"mouse-or-touch\";\n}): number[] {\n  if (fuzzyNumbersEqual(delta, 0)) {\n    return prevLayout;\n  }\n\n  const nextLayout = [...prevLayout];\n\n  let deltaApplied = 0;\n\n  //const DEBUG = [];\n  //DEBUG.push(`adjustLayoutByDelta() ${prevLayout.join(\", \")}`);\n  //DEBUG.push(`  delta: ${delta}`);\n  //DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\n  //DEBUG.push(`  trigger: ${trigger}`);\n  //DEBUG.push(\"\");\n\n  // A resizing panel affects the panels before or after it.\n  //\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\n  //\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\n\n  {\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\n    if (trigger === \"keyboard\") {\n      {\n        // Check if we should expand a collapsed panel\n        const index = delta < 0 ? pivotIndices[1]! : pivotIndices[0]!;\n        const constraints = panelConstraints[index]!;\n        //DEBUG.push(`edge case check 1: ${index}`);\n        //DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n        if (constraints.collapsible) {\n          const prevSize = prevLayout[index]!;\n          const { collapsedSizePercentage, minSizePercentage } =\n            computePercentagePanelConstraints(\n              panelConstraints,\n              index,\n              groupSizePixels\n            );\n\n          if (fuzzyNumbersEqual(prevSize, collapsedSizePercentage)) {\n            const localDelta = minSizePercentage - prevSize;\n            //DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              //DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n\n      {\n        // Check if we should collapse a panel at its minimum size\n        const index = delta < 0 ? pivotIndices[0]! : pivotIndices[1]!;\n        const constraints = panelConstraints[index]!;\n        //DEBUG.push(`edge case check 2: ${index}`);\n        //DEBUG.push(`  -> collapsible? ${constraints.collapsible}`);\n        if (constraints.collapsible) {\n          const prevSize = prevLayout[index]!;\n          const { collapsedSizePercentage, minSizePercentage } =\n            computePercentagePanelConstraints(\n              panelConstraints,\n              index,\n              groupSizePixels\n            );\n\n          if (fuzzyNumbersEqual(prevSize, minSizePercentage)) {\n            const localDelta = prevSize - collapsedSizePercentage;\n            //DEBUG.push(`  -> expand delta: ${localDelta}`);\n\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\n              delta = delta < 0 ? 0 - localDelta : localDelta;\n              //DEBUG.push(`  -> delta: ${delta}`);\n            }\n          }\n        }\n      }\n    }\n    //DEBUG.push(\"\");\n  }\n\n  {\n    // Pre-calculate max available delta in the opposite direction of our pivot.\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\n    // If this amount is less than the requested delta, adjust the requested delta.\n    // If this amount is greater than the requested delta, that's useful information too\n    // as an expanding panel might change from collapsed to min size.\n\n    const increment = delta < 0 ? 1 : -1;\n\n    let index = delta < 0 ? pivotIndices[1]! : pivotIndices[0]!;\n    let maxAvailableDelta = 0;\n\n    //DEBUG.push(\"pre calc...\");\n    while (true) {\n      const prevSize = prevLayout[index];\n      const maxSafeSize = resizePanel({\n        groupSizePixels,\n        panelConstraints,\n        panelIndex: index,\n        size: 100,\n      });\n      const delta = maxSafeSize - prevSize;\n      //DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\n\n      maxAvailableDelta += delta;\n      index += increment;\n\n      if (index < 0 || index >= panelConstraints.length) {\n        break;\n      }\n    }\n\n    //DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\n    //DEBUG.push(`  -> adjusted delta: ${delta}`);\n    //DEBUG.push(\"\");\n  }\n\n  {\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\n\n    const pivotIndex = delta < 0 ? pivotIndices[0]! : pivotIndices[1]!;\n    let index = pivotIndex;\n    while (index >= 0 && index < panelConstraints.length) {\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\n\n      const prevSize = prevLayout[index]!;\n      const unsafeSize = prevSize - deltaRemaining;\n      const safeSize = resizePanel({\n        groupSizePixels,\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize,\n      });\n\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n        deltaApplied += prevSize - safeSize;\n\n        nextLayout[index] = safeSize;\n\n        if (\n          deltaApplied\n            .toPrecision(3)\n            .localeCompare(Math.abs(delta).toPrecision(3), undefined, {\n              numeric: true,\n            }) >= 0\n        ) {\n          break;\n        }\n      }\n\n      if (delta < 0) {\n        index--;\n      } else {\n        index++;\n      }\n    }\n  }\n  //DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\n  //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  //DEBUG.push(\"\");\n\n  // If we were unable to resize any of the panels panels, return the previous state.\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\n  if (fuzzyNumbersEqual(deltaApplied, 0)) {\n    //console.log(DEBUG.join(\"\\n\"));\n    return prevLayout;\n  }\n\n  {\n    // Now distribute the applied delta to the panels in the other direction\n    const pivotIndex = delta < 0 ? pivotIndices[1]! : pivotIndices[0]!;\n\n    const unsafeSize = prevLayout[pivotIndex]! + deltaApplied;\n    const safeSize = resizePanel({\n      groupSizePixels,\n      panelConstraints,\n      panelIndex: pivotIndex,\n      size: unsafeSize,\n    });\n\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\n    nextLayout[pivotIndex] = safeSize;\n\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\n      let deltaRemaining = unsafeSize - safeSize;\n\n      const pivotIndex = delta < 0 ? pivotIndices[1]! : pivotIndices[0]!;\n      let index = pivotIndex;\n      while (index >= 0 && index < panelConstraints.length) {\n        const prevSize = nextLayout[index]!;\n        const unsafeSize = prevSize + deltaRemaining;\n        const safeSize = resizePanel({\n          groupSizePixels,\n          panelConstraints,\n          panelIndex: index,\n          size: unsafeSize,\n        });\n\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\n          deltaRemaining -= safeSize - prevSize;\n\n          nextLayout[index] = safeSize;\n        }\n\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\n          break;\n        }\n\n        if (delta > 0) {\n          index--;\n        } else {\n          index++;\n        }\n      }\n    }\n  }\n  //DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\n  //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  //DEBUG.push(\"\");\n\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\n  deltaApplied = 100 - totalSize;\n  //DEBUG.push(`total size: ${totalSize}`);\n  //DEBUG.push(`  deltaApplied: ${deltaApplied}`);\n  //console.log(DEBUG.join(\"\\n\"));\n\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\n    return prevLayout;\n  }\n\n  return nextLayout;\n}\n","import { PanelConstraints } from \"../Panel\";\nimport { convertPixelConstraintsToPercentages } from \"./convertPixelConstraintsToPercentages\";\n\nexport function computePercentagePanelConstraints(\n  panelConstraintsArray: PanelConstraints[],\n  panelIndex: number,\n  groupSizePixels: number\n): {\n  collapsedSizePercentage: number;\n  defaultSizePercentage: number | undefined;\n  maxSizePercentage: number;\n  minSizePercentage: number;\n} {\n  // All panel constraints, excluding the current one\n  let totalMinConstraints = 0;\n  let totalMaxConstraints = 0;\n\n  for (let index = 0; index < panelConstraintsArray.length; index++) {\n    if (index !== panelIndex) {\n      const { collapsible } = panelConstraintsArray[index]!;\n      const { collapsedSizePercentage, maxSizePercentage, minSizePercentage } =\n        convertPixelConstraintsToPercentages(\n          panelConstraintsArray[index]!,\n          groupSizePixels\n        );\n\n      totalMaxConstraints += maxSizePercentage;\n      totalMinConstraints += collapsible\n        ? collapsedSizePercentage\n        : minSizePercentage;\n    }\n  }\n\n  const {\n    collapsedSizePercentage,\n    defaultSizePercentage,\n    maxSizePercentage,\n    minSizePercentage,\n  } = convertPixelConstraintsToPercentages(\n    panelConstraintsArray[panelIndex]!,\n    groupSizePixels\n  );\n\n  return {\n    collapsedSizePercentage,\n    defaultSizePercentage,\n    maxSizePercentage:\n      panelConstraintsArray.length > 1\n        ? Math.min(maxSizePercentage, 100 - totalMinConstraints)\n        : maxSizePercentage,\n    minSizePercentage:\n      panelConstraintsArray.length > 1\n        ? Math.max(minSizePercentage, 100 - totalMaxConstraints)\n        : minSizePercentage,\n  };\n}\n","import { PanelConstraints } from \"../Panel\";\nimport { convertPixelsToPercentage } from \"./convertPixelsToPercentage\";\n\nexport function convertPixelConstraintsToPercentages(\n  panelConstraints: PanelConstraints,\n  groupSizePixels: number\n): {\n  collapsedSizePercentage: number;\n  defaultSizePercentage: number | undefined;\n  maxSizePercentage: number;\n  minSizePercentage: number;\n} {\n  let {\n    collapsedSizePercentage = 0,\n    collapsedSizePixels,\n    defaultSizePercentage,\n    defaultSizePixels,\n    maxSizePercentage = 100,\n    maxSizePixels,\n    minSizePercentage = 0,\n    minSizePixels,\n  } = panelConstraints;\n\n  const hasPixelConstraints =\n    collapsedSizePixels != null ||\n    defaultSizePixels != null ||\n    minSizePixels != null ||\n    maxSizePixels != null;\n\n  if (hasPixelConstraints && groupSizePixels <= 0) {\n    console.warn(`WARNING: Invalid group size: ${groupSizePixels}px`);\n\n    return {\n      collapsedSizePercentage: 0,\n      defaultSizePercentage,\n      maxSizePercentage: 0,\n      minSizePercentage: 0,\n    };\n  }\n\n  if (collapsedSizePixels != null) {\n    collapsedSizePercentage = convertPixelsToPercentage(\n      collapsedSizePixels,\n      groupSizePixels\n    );\n  }\n  if (defaultSizePixels != null) {\n    defaultSizePercentage = convertPixelsToPercentage(\n      defaultSizePixels,\n      groupSizePixels\n    );\n  }\n  if (minSizePixels != null) {\n    minSizePercentage = convertPixelsToPercentage(\n      minSizePixels,\n      groupSizePixels\n    );\n  }\n  if (maxSizePixels != null) {\n    maxSizePercentage = convertPixelsToPercentage(\n      maxSizePixels,\n      groupSizePixels\n    );\n  }\n\n  return {\n    collapsedSizePercentage,\n    defaultSizePercentage,\n    maxSizePercentage,\n    minSizePercentage,\n  };\n}\n","export function convertPixelsToPercentage(\n  pixels: number,\n  groupSizePixels: number\n): number {\n  return (pixels / groupSizePixels) * 100;\n}\n","import { PRECISION } from \"../../constants\";\n\nexport function fuzzyCompareNumbers(\n  actual: number,\n  expected: number,\n  fractionDigits: number = PRECISION\n): number {\n  actual = parseFloat(actual.toFixed(fractionDigits));\n  expected = parseFloat(expected.toFixed(fractionDigits));\n\n  const delta = actual - expected;\n  if (delta === 0) {\n    return 0;\n  } else {\n    return delta > 0 ? 1 : -1;\n  }\n}\n","export const PRECISION = 10;\n","import { fuzzyCompareNumbers } from \"./fuzzyCompareNumbers\";\n\nexport function fuzzyNumbersEqual(\n  actual: number,\n  expected: number,\n  fractionDigits?: number\n): boolean {\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\n}\n","import { PanelConstraints } from \"../Panel\";\nimport { computePercentagePanelConstraints } from \"./computePercentagePanelConstraints\";\nimport { fuzzyCompareNumbers } from \"./numbers/fuzzyCompareNumbers\";\n\n// Panel size must be in percentages; pixel values should be pre-converted\nexport function resizePanel({\n  groupSizePixels,\n  panelConstraints,\n  panelIndex,\n  size,\n}: {\n  groupSizePixels: number;\n  panelConstraints: PanelConstraints[];\n  panelIndex: number;\n  size: number;\n}) {\n  const hasPixelConstraints = panelConstraints.some(\n    ({\n      collapsedSizePixels,\n      defaultSizePixels,\n      minSizePixels,\n      maxSizePixels,\n    }) =>\n      collapsedSizePixels != null ||\n      defaultSizePixels != null ||\n      minSizePixels != null ||\n      maxSizePixels != null\n  );\n\n  if (hasPixelConstraints && groupSizePixels <= 0) {\n    console.warn(`WARNING: Invalid group size: ${groupSizePixels}px`);\n\n    return 0;\n  }\n\n  let { collapsible } = panelConstraints[panelIndex]!;\n\n  const { collapsedSizePercentage, maxSizePercentage, minSizePercentage } =\n    computePercentagePanelConstraints(\n      panelConstraints,\n      panelIndex,\n      groupSizePixels\n    );\n\n  if (minSizePercentage != null) {\n    if (fuzzyCompareNumbers(size, minSizePercentage) < 0) {\n      if (collapsible) {\n        // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\n        const halfwayPoint = (collapsedSizePercentage + minSizePercentage) / 2;\n        if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\n          size = collapsedSizePercentage;\n        } else {\n          size = minSizePercentage;\n        }\n      } else {\n        size = minSizePercentage;\n      }\n    }\n  }\n\n  if (maxSizePercentage != null) {\n    size = Math.min(maxSizePercentage, size);\n  }\n\n  return size;\n}\n","export function assert(\n  expectedCondition: boolean,\n  message: string = \"Assertion failed!\"\n): asserts expectedCondition {\n  if (!expectedCondition) {\n    console.error(message);\n\n    throw Error(message);\n  }\n}\n","import { PanelData } from \"../Panel\";\nimport { getPercentageSizeFromMixedSizes } from \"./getPercentageSizeFromMixedSizes\";\n\nexport function calculateAriaValues({\n  groupSizePixels,\n  layout,\n  panelsArray,\n  pivotIndices,\n}: {\n  groupSizePixels: number;\n  layout: number[];\n  panelsArray: PanelData[];\n  pivotIndices: number[];\n}) {\n  let currentMinSize = 0;\n  let currentMaxSize = 100;\n  let totalMinSize = 0;\n  let totalMaxSize = 0;\n\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\n  panelsArray.forEach((panelData, index) => {\n    const { constraints } = panelData;\n    const {\n      maxSizePercentage,\n      maxSizePixels,\n      minSizePercentage,\n      minSizePixels,\n    } = constraints;\n\n    const minSize =\n      getPercentageSizeFromMixedSizes(\n        {\n          sizePercentage: minSizePercentage,\n          sizePixels: minSizePixels,\n        },\n        groupSizePixels\n      ) ?? 0;\n\n    const maxSize =\n      getPercentageSizeFromMixedSizes(\n        {\n          sizePercentage: maxSizePercentage,\n          sizePixels: maxSizePixels,\n        },\n        groupSizePixels\n      ) ?? 100;\n\n    if (index === pivotIndices[0]) {\n      currentMinSize = minSize;\n      currentMaxSize = maxSize;\n    } else {\n      totalMinSize += minSize;\n      totalMaxSize += maxSize;\n    }\n  });\n\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\n\n  const valueNow = layout[pivotIndices[0]];\n\n  return {\n    valueMax,\n    valueMin,\n    valueNow,\n  };\n}\n","import { MixedSizes } from \"../types\";\nimport { convertPixelsToPercentage } from \"./convertPixelsToPercentage\";\n\nexport function getPercentageSizeFromMixedSizes(\n  { sizePercentage, sizePixels }: Partial<MixedSizes>,\n  groupSizePixels: number\n): number | undefined {\n  if (sizePercentage != null) {\n    return sizePercentage;\n  } else if (sizePixels != null) {\n    return convertPixelsToPercentage(sizePixels, groupSizePixels);\n  }\n\n  return undefined;\n}\n","import { getResizeHandleElementIndex } from \"../utils/dom/getResizeHandleElementIndex\";\n\nexport function determinePivotIndices(\n  groupId: string,\n  dragHandleId: string\n): [indexBefore: number, indexAfter: number] {\n  const index = getResizeHandleElementIndex(groupId, dragHandleId);\n\n  return index != null ? [index, index + 1] : [-1, -1];\n}\n","import { getResizeHandleElementsForGroup } from \"./getResizeHandleElementsForGroup\";\n\nexport function getResizeHandleElementIndex(\n  groupId: string,\n  id: string\n): number | null {\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = handles.findIndex(\n    (handle) => handle.getAttribute(\"data-panel-resize-handle-id\") === id\n  );\n  return index ?? null;\n}\n","export function getResizeHandleElementsForGroup(\n  groupId: string\n): HTMLDivElement[] {\n  return Array.from(\n    document.querySelectorAll(\n      `[data-panel-resize-handle-id][data-panel-group-id=\"${groupId}\"]`\n    )\n  );\n}\n","import { getPanelGroupElement } from \"./getPanelGroupElement\";\nimport { getResizeHandleElementsForGroup } from \"./getResizeHandleElementsForGroup\";\n\nexport function calculateAvailablePanelSizeInPixels(groupId: string): number {\n  const panelGroupElement = getPanelGroupElement(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n\n  const direction = panelGroupElement.getAttribute(\n    \"data-panel-group-direction\"\n  );\n  const resizeHandles = getResizeHandleElementsForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return (\n      panelGroupElement.offsetWidth -\n      resizeHandles.reduce((accumulated, handle) => {\n        return accumulated + handle.offsetWidth;\n      }, 0)\n    );\n  } else {\n    return (\n      panelGroupElement.offsetHeight -\n      resizeHandles.reduce((accumulated, handle) => {\n        return accumulated + handle.offsetHeight;\n      }, 0)\n    );\n  }\n}\n","export function getPanelGroupElement(id: string): HTMLDivElement | null {\n  const element = document.querySelector(\n    `[data-panel-group][data-panel-group-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n","import { getPanelGroupElement } from \"./getPanelGroupElement\";\nimport { getResizeHandleElementsForGroup } from \"./getResizeHandleElementsForGroup\";\n\nexport function getAvailableGroupSizePixels(groupId: string): number {\n  const panelGroupElement = getPanelGroupElement(groupId);\n  if (panelGroupElement == null) {\n    return NaN;\n  }\n\n  const direction = panelGroupElement.getAttribute(\n    \"data-panel-group-direction\"\n  );\n  const resizeHandles = getResizeHandleElementsForGroup(groupId);\n  if (direction === \"horizontal\") {\n    return (\n      panelGroupElement.offsetWidth -\n      resizeHandles.reduce((accumulated, handle) => {\n        return accumulated + handle.offsetWidth;\n      }, 0)\n    );\n  } else {\n    return (\n      panelGroupElement.offsetHeight -\n      resizeHandles.reduce((accumulated, handle) => {\n        return accumulated + handle.offsetHeight;\n      }, 0)\n    );\n  }\n}\n","import { PanelData } from \"../../Panel\";\nimport { getResizeHandleElement } from \"./getResizeHandleElement\";\nimport { getResizeHandleElementsForGroup } from \"./getResizeHandleElementsForGroup\";\n\nexport function getResizeHandlePanelIds(\n  groupId: string,\n  handleId: string,\n  panelsArray: PanelData[]\n): [idBefore: string | null, idAfter: string | null] {\n  const handle = getResizeHandleElement(handleId);\n  const handles = getResizeHandleElementsForGroup(groupId);\n  const index = handle ? handles.indexOf(handle) : -1;\n\n  const idBefore: string | null = panelsArray[index]?.id ?? null;\n  const idAfter: string | null = panelsArray[index + 1]?.id ?? null;\n\n  return [idBefore, idAfter];\n}\n","export function getResizeHandleElement(id: string): HTMLDivElement | null {\n  const element = document.querySelector(\n    `[data-panel-resize-handle-id=\"${id}\"]`\n  );\n  if (element) {\n    return element as HTMLDivElement;\n  }\n  return null;\n}\n","export function areEqual(arrayA: any[], arrayB: any[]): boolean {\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (let index = 0; index < arrayA.length; index++) {\n    if (arrayA[index] !== arrayB[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { DragState, ResizeEvent } from \"../PanelGroupContext\";\nimport { Direction } from \"../types\";\nimport { getPanelGroupElement } from \"../utils/dom/getPanelGroupElement\";\nimport { calculateDragOffsetPercentage } from \"./calculateDragOffsetPercentage\";\nimport { isKeyDown } from \"./events\";\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\nexport function calculateDeltaPercentage(\n  event: ResizeEvent,\n  groupId: string,\n  dragHandleId: string,\n  direction: Direction,\n  initialDragState: DragState,\n  keyboardResizeByOptions: {\n    percentage: number | null;\n    pixels: number | null;\n  }\n): number {\n  if (isKeyDown(event)) {\n    const isHorizontal = direction === \"horizontal\";\n\n    const groupElement = getPanelGroupElement(groupId)!;\n    const rect = groupElement.getBoundingClientRect();\n    const groupSizeInPixels = isHorizontal ? rect.width : rect.height;\n\n    let delta = 0;\n    if (event.shiftKey) {\n      delta = 100;\n    } else if (keyboardResizeByOptions.percentage != null) {\n      delta = keyboardResizeByOptions.percentage;\n    } else if (keyboardResizeByOptions.pixels != null) {\n      delta = keyboardResizeByOptions.pixels / groupSizeInPixels;\n    } else {\n      delta = 10;\n    }\n\n    let movement = 0;\n    switch (event.key) {\n      case \"ArrowDown\":\n        movement = isHorizontal ? 0 : delta;\n        break;\n      case \"ArrowLeft\":\n        movement = isHorizontal ? -delta : 0;\n        break;\n      case \"ArrowRight\":\n        movement = isHorizontal ? delta : 0;\n        break;\n      case \"ArrowUp\":\n        movement = isHorizontal ? 0 : -delta;\n        break;\n      case \"End\":\n        movement = 100;\n        break;\n      case \"Home\":\n        movement = -100;\n        break;\n    }\n\n    return movement;\n  } else {\n    return calculateDragOffsetPercentage(\n      event,\n      dragHandleId,\n      direction,\n      initialDragState\n    );\n  }\n}\n","import { DragState, ResizeEvent } from \"../PanelGroupContext\";\nimport { Direction } from \"../types\";\nimport { getPanelGroupElement } from \"../utils/dom/getPanelGroupElement\";\nimport { getResizeHandleElement } from \"../utils/dom/getResizeHandleElement\";\nimport { getResizeEventCursorPosition } from \"./getResizeEventCursorPosition\";\n\nexport function calculateDragOffsetPercentage(\n  event: ResizeEvent,\n  dragHandleId: string,\n  direction: Direction,\n  initialDragState: DragState\n): number {\n  const isHorizontal = direction === \"horizontal\";\n\n  const handleElement = getResizeHandleElement(dragHandleId)!;\n  const groupId = handleElement.getAttribute(\"data-panel-group-id\")!;\n\n  let { initialCursorPosition } = initialDragState;\n\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\n\n  const groupElement = getPanelGroupElement(groupId)!;\n  const groupRect = groupElement.getBoundingClientRect();\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\n\n  const offsetPixels = cursorPosition - initialCursorPosition;\n  const offsetPercentage = (offsetPixels / groupSizeInPixels) * 100;\n\n  return offsetPercentage;\n}\n","import { ResizeEvent } from \"../PanelGroupContext\";\nimport { Direction } from \"../types\";\nimport { isMouseEvent, isTouchEvent } from \"./events\";\n\nexport function getResizeEventCursorPosition(\n  direction: Direction,\n  event: ResizeEvent\n): number {\n  const isHorizontal = direction === \"horizontal\";\n\n  if (isMouseEvent(event)) {\n    return isHorizontal ? event.clientX : event.clientY;\n  } else if (isTouchEvent(event)) {\n    const firstTouch = event.touches[0];\n    return isHorizontal ? firstTouch.screenX : firstTouch.screenY;\n  } else {\n    throw Error(`Unsupported event type \"${event.type}\"`);\n  }\n}\n","import { ResizeEvent } from \"../PanelGroupContext\";\n\nexport function isKeyDown(event: ResizeEvent): event is KeyboardEvent {\n  return event.type === \"keydown\";\n}\n\nexport function isMouseEvent(event: ResizeEvent): event is MouseEvent {\n  return event.type.startsWith(\"mouse\");\n}\n\nexport function isTouchEvent(event: ResizeEvent): event is TouchEvent {\n  return event.type.startsWith(\"touch\");\n}\n","import { PanelData } from \"../Panel\";\nimport { computePercentagePanelConstraints } from \"./computePercentagePanelConstraints\";\n\nexport function calculateUnsafeDefaultLayout({\n  groupSizePixels,\n  panelDataArray,\n}: {\n  groupSizePixels: number;\n  panelDataArray: PanelData[];\n}): number[] {\n  const layout = Array<number>(panelDataArray.length);\n\n  const panelDataConstraints = panelDataArray.map(\n    (panelData) => panelData.constraints\n  );\n\n  let numPanelsWithSizes = 0;\n  let remainingSize = 100;\n\n  // Distribute default sizes first\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const { defaultSizePercentage } = computePercentagePanelConstraints(\n      panelDataConstraints,\n      index,\n      groupSizePixels\n    );\n\n    if (defaultSizePercentage != null) {\n      numPanelsWithSizes++;\n      layout[index] = defaultSizePercentage;\n      remainingSize -= defaultSizePercentage;\n    }\n  }\n\n  // Remaining size should be distributed evenly between panels without default sizes\n  for (let index = 0; index < panelDataArray.length; index++) {\n    const { defaultSizePercentage } = computePercentagePanelConstraints(\n      panelDataConstraints,\n      index,\n      groupSizePixels\n    );\n    if (defaultSizePercentage != null) {\n      continue;\n    }\n\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\n    const size = remainingSize / numRemainingPanels;\n\n    numPanelsWithSizes++;\n    layout[index] = size;\n    remainingSize -= size;\n  }\n\n  return layout;\n}\n","import { PanelData } from \"../Panel\";\nimport { MixedSizes } from \"../types\";\nimport { calculateAvailablePanelSizeInPixels } from \"../utils/dom/calculateAvailablePanelSizeInPixels\";\nimport { convertPercentageToPixels } from \"./convertPercentageToPixels\";\nimport { getPercentageSizeFromMixedSizes } from \"./getPercentageSizeFromMixedSizes\";\n\n// Layout should be pre-converted into percentages\nexport function callPanelCallbacks(\n  groupId: string,\n  panelsArray: PanelData[],\n  layout: number[],\n  panelIdToLastNotifiedMixedSizesMap: Record<string, MixedSizes>\n) {\n  const groupSizePixels = calculateAvailablePanelSizeInPixels(groupId);\n\n  layout.forEach((sizePercentage, index) => {\n    const panelData = panelsArray[index];\n    if (!panelData) {\n      // Handle initial mount (when panels are registered too late to be in the panels array)\n      // The subsequent render+effects will handle the resize notification\n      return;\n    }\n\n    const { callbacks, constraints, id: panelId } = panelData;\n    const { collapsible } = constraints;\n\n    const mixedSizes: MixedSizes = {\n      sizePercentage,\n      sizePixels: convertPercentageToPixels(sizePercentage, groupSizePixels),\n    };\n\n    const lastNotifiedMixedSizes = panelIdToLastNotifiedMixedSizesMap[panelId];\n    if (\n      lastNotifiedMixedSizes == null ||\n      mixedSizes.sizePercentage !== lastNotifiedMixedSizes.sizePercentage ||\n      mixedSizes.sizePixels !== lastNotifiedMixedSizes.sizePixels\n    ) {\n      panelIdToLastNotifiedMixedSizesMap[panelId] = mixedSizes;\n\n      const { onCollapse, onExpand, onResize } = callbacks;\n\n      if (onResize) {\n        onResize(mixedSizes, lastNotifiedMixedSizes);\n      }\n\n      if (collapsible && (onCollapse || onExpand)) {\n        const collapsedSize =\n          getPercentageSizeFromMixedSizes(\n            {\n              sizePercentage: constraints.collapsedSizePercentage,\n              sizePixels: constraints.collapsedSizePixels,\n            },\n            groupSizePixels\n          ) ?? 0;\n\n        const size = getPercentageSizeFromMixedSizes(\n          mixedSizes,\n          groupSizePixels\n        );\n\n        if (\n          onExpand &&\n          (lastNotifiedMixedSizes == null ||\n            lastNotifiedMixedSizes.sizePercentage === collapsedSize) &&\n          size !== collapsedSize\n        ) {\n          onExpand();\n        }\n\n        if (\n          onCollapse &&\n          (lastNotifiedMixedSizes == null ||\n            lastNotifiedMixedSizes.sizePercentage !== collapsedSize) &&\n          size === collapsedSize\n        ) {\n          onCollapse();\n        }\n      }\n    }\n  });\n}\n","export function convertPercentageToPixels(\n  percentage: number,\n  groupSizePixels: number\n): number {\n  return (percentage / 100) * groupSizePixels;\n}\n","export function compareLayouts(a: number[], b: number[]) {\n  if (a.length !== b.length) {\n    return false;\n  } else {\n    for (let index = 0; index < a.length; index++) {\n      if (a[index] != b[index]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n","// This method returns a number between 1 and 100 representing\n\nimport { PanelData } from \"../Panel\";\nimport { DragState } from \"../PanelGroupContext\";\nimport { CSSProperties } from \"../vendor/react\";\n\n// the % of the group's overall space this panel should occupy.\nexport function computePanelFlexBoxStyle({\n  dragState,\n  layout,\n  panelData,\n  panelIndex,\n  precision = 3,\n}: {\n  layout: number[];\n  dragState: DragState | null;\n  panelData: PanelData[];\n  panelIndex: number;\n  precision?: number;\n}): CSSProperties {\n  const size = layout[panelIndex];\n\n  let flexGrow;\n  if (panelData.length === 1) {\n    flexGrow = \"1\";\n  } else if (size == null) {\n    // Initial render (before panels have registered themselves)\n    flexGrow = \"1\";\n  } else {\n    flexGrow = size.toPrecision(precision);\n  }\n\n  return {\n    flexBasis: 0,\n    flexGrow,\n    flexShrink: 1,\n\n    // Without this, Panel sizes may be unintentionally overridden by their content\n    overflow: \"hidden\",\n\n    // Disable pointer events inside of a panel during resize\n    // This avoid edge cases like nested iframes\n    pointerEvents: dragState !== null ? \"none\" : undefined,\n  };\n}\n","type CursorState =\n  | \"horizontal\"\n  | \"horizontal-max\"\n  | \"horizontal-min\"\n  | \"vertical\"\n  | \"vertical-max\"\n  | \"vertical-min\";\n\nlet currentState: CursorState | null = null;\nlet element: HTMLStyleElement | null = null;\n\nexport function getCursorStyle(state: CursorState): string {\n  switch (state) {\n    case \"horizontal\":\n      return \"ew-resize\";\n    case \"horizontal-max\":\n      return \"w-resize\";\n    case \"horizontal-min\":\n      return \"e-resize\";\n    case \"vertical\":\n      return \"ns-resize\";\n    case \"vertical-max\":\n      return \"n-resize\";\n    case \"vertical-min\":\n      return \"s-resize\";\n  }\n}\n\nexport function resetGlobalCursorStyle() {\n  if (element !== null) {\n    document.head.removeChild(element);\n\n    currentState = null;\n    element = null;\n  }\n}\n\nexport function setGlobalCursorStyle(state: CursorState) {\n  if (currentState === state) {\n    return;\n  }\n\n  currentState = state;\n\n  const style = getCursorStyle(state);\n\n  if (element === null) {\n    element = document.createElement(\"style\");\n\n    document.head.appendChild(element);\n  }\n\n  element.innerHTML = `*{cursor: ${style}!important;}`;\n}\n","export default function debounce<T extends Function>(\n  callback: T,\n  durationMs: number = 10\n) {\n  let timeoutId: NodeJS.Timeout | null = null;\n\n  let callable = (...args: any) => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId);\n    }\n\n    timeoutId = setTimeout(() => {\n      callback(...args);\n    }, durationMs);\n  };\n\n  return callable as unknown as T;\n}\n","export function getPanelElementsForGroup(groupId: string): HTMLDivElement[] {\n  return Array.from(\n    document.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`)\n  );\n}\n","import { PanelGroupStorage } from \"../PanelGroup\";\n\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\n// or on a browser with cookies/storage disabled.\n// In either case, this function avoids accessing localStorage until needed,\n// and avoids throwing user-visible errors.\nexport function initializeDefaultStorage(storageObject: PanelGroupStorage) {\n  try {\n    if (typeof localStorage !== \"undefined\") {\n      // Bypass this check for future calls\n      storageObject.getItem = (name: string) => {\n        return localStorage.getItem(name);\n      };\n      storageObject.setItem = (name: string, value: string) => {\n        localStorage.setItem(name, value);\n      };\n    } else {\n      throw new Error(\"localStorage not supported in this environment\");\n    }\n  } catch (error) {\n    console.error(error);\n\n    storageObject.getItem = () => null;\n    storageObject.setItem = () => {};\n  }\n}\n","import { PanelData } from \"../Panel\";\nimport { PanelGroupStorage } from \"../PanelGroup\";\n\ntype SerializedPanelGroupState = { [panelIds: string]: number[] };\n\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\n// so they should not be used as part of the serialization key.\n// Using the min/max size attributes should work well enough as a backup.\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\nfunction getSerializationKey(panels: PanelData[]): string {\n  return panels\n    .map((panel) => {\n      const { constraints, id, idIsFromProps, order } = panel;\n      if (idIsFromProps) {\n        return id;\n      } else {\n        return `${order}:${JSON.stringify(constraints)}`;\n      }\n    })\n    .sort((a, b) => a.localeCompare(b))\n    .join(\",\");\n}\n\nfunction loadSerializedPanelGroupState(\n  autoSaveId: string,\n  storage: PanelGroupStorage\n): SerializedPanelGroupState | null {\n  try {\n    const serialized = storage.getItem(`PanelGroup:sizes:${autoSaveId}`);\n    if (serialized) {\n      const parsed = JSON.parse(serialized);\n      if (typeof parsed === \"object\" && parsed != null) {\n        return parsed;\n      }\n    }\n  } catch (error) {}\n\n  return null;\n}\n\nexport function loadPanelLayout(\n  autoSaveId: string,\n  panels: PanelData[],\n  storage: PanelGroupStorage\n): number[] | null {\n  const state = loadSerializedPanelGroupState(autoSaveId, storage);\n  if (state) {\n    const key = getSerializationKey(panels);\n    return state[key] ?? null;\n  }\n\n  return null;\n}\n\nexport function savePanelGroupLayout(\n  autoSaveId: string,\n  panels: PanelData[],\n  sizes: number[],\n  storage: PanelGroupStorage\n): void {\n  const key = getSerializationKey(panels);\n  const state = loadSerializedPanelGroupState(autoSaveId, storage) || {};\n  state[key] = sizes;\n\n  try {\n    storage.setItem(`PanelGroup:sizes:${autoSaveId}`, JSON.stringify(state));\n  } catch (error) {\n    console.error(error);\n  }\n}\n","import { PanelConstraints } from \"../Panel\";\n\nexport function shouldMonitorPixelBasedConstraints(\n  constraints: PanelConstraints[]\n): boolean {\n  return constraints.some((constraints) => {\n    return (\n      constraints.collapsedSizePixels !== undefined ||\n      constraints.maxSizePixels !== undefined ||\n      constraints.minSizePixels !== undefined\n    );\n  });\n}\n","import { isDevelopment } from \"#is-development\";\nimport { PanelConstraints } from \"../Panel\";\nimport { computePercentagePanelConstraints } from \"./computePercentagePanelConstraints\";\n\nexport function validatePanelConstraints({\n  groupSizePixels,\n  panelConstraints,\n  panelId,\n  panelIndex,\n}: {\n  groupSizePixels: number;\n  panelConstraints: PanelConstraints[];\n  panelId: string | undefined;\n  panelIndex: number;\n}): boolean {\n  if (isDevelopment) {\n    const warnings = [];\n\n    {\n      const {\n        collapsedSizePercentage,\n        collapsedSizePixels,\n        defaultSizePercentage,\n        defaultSizePixels,\n        maxSizePercentage,\n        maxSizePixels,\n        minSizePercentage,\n        minSizePixels,\n      } = panelConstraints[panelIndex]!;\n\n      const conflictingUnits: string[] = [];\n\n      if (collapsedSizePercentage != null && collapsedSizePixels != null) {\n        conflictingUnits.push(\"collapsed size\");\n      }\n      if (defaultSizePercentage != null && defaultSizePixels != null) {\n        conflictingUnits.push(\"default size\");\n      }\n      if (maxSizePercentage != null && maxSizePixels != null) {\n        conflictingUnits.push(\"max size\");\n      }\n      if (minSizePercentage != null && minSizePixels != null) {\n        conflictingUnits.push(\"min size\");\n      }\n\n      if (conflictingUnits.length > 0) {\n        warnings.push(\n          `should not specify both percentage and pixel units for: ${conflictingUnits.join(\n            \", \"\n          )}`\n        );\n      }\n    }\n\n    {\n      const {\n        collapsedSizePercentage,\n        defaultSizePercentage,\n        maxSizePercentage,\n        minSizePercentage,\n      } = computePercentagePanelConstraints(\n        panelConstraints,\n        panelIndex,\n        groupSizePixels\n      );\n\n      if (minSizePercentage > maxSizePercentage) {\n        warnings.push(\n          `min size (${minSizePercentage}%) should not be greater than max size (${maxSizePercentage}%)`\n        );\n      }\n\n      if (defaultSizePercentage != null) {\n        if (defaultSizePercentage < 0) {\n          warnings.push(\"default size should not be less than 0\");\n        } else if (defaultSizePercentage < minSizePercentage) {\n          warnings.push(\"default size should not be less than min size\");\n        }\n\n        if (defaultSizePercentage > 100) {\n          warnings.push(\"default size should not be greater than 100\");\n        } else if (defaultSizePercentage > maxSizePercentage) {\n          warnings.push(\"default size should not be greater than max size\");\n        }\n      }\n\n      if (collapsedSizePercentage > minSizePercentage) {\n        warnings.push(\"collapsed size should not be greater than min size\");\n      }\n    }\n\n    if (warnings.length > 0) {\n      const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\n      console.warn(\n        `${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`\n      );\n\n      return false;\n    }\n  }\n\n  return true;\n}\n","import { isDevelopment } from \"#is-development\";\nimport { PanelConstraints } from \"../Panel\";\nimport { fuzzyNumbersEqual } from \"./numbers/fuzzyNumbersEqual\";\nimport { resizePanel } from \"./resizePanel\";\n\n// All units must be in percentages; pixel values should be pre-converted\nexport function validatePanelGroupLayout({\n  groupSizePixels,\n  layout: prevLayout,\n  panelConstraints,\n}: {\n  groupSizePixels: number;\n  layout: number[];\n  panelConstraints: PanelConstraints[];\n}): number[] {\n  const nextLayout = [...prevLayout];\n\n  // Validate layout expectations\n  if (nextLayout.length !== panelConstraints.length) {\n    throw Error(\n      `Invalid ${panelConstraints.length} panel layout: ${nextLayout\n        .map((size) => `${size}%`)\n        .join(\", \")}`\n    );\n  } else if (\n    !fuzzyNumbersEqual(\n      nextLayout.reduce((accumulated, current) => accumulated + current, 0),\n      100\n    )\n  ) {\n    // This is not ideal so we should warn about it, but it may be recoverable in some cases\n    // (especially if the amount is small)\n    if (isDevelopment) {\n      console.warn(\n        `WARNING: Invalid layout total size: ${nextLayout\n          .map((size) => `${size}%`)\n          .join(\", \")}`\n      );\n    }\n  }\n\n  let remainingSize = 0;\n\n  // First pass: Validate the proposed layout given each panel's constraints\n  for (let index = 0; index < panelConstraints.length; index++) {\n    const unsafeSize = nextLayout[index]!;\n\n    const safeSize = resizePanel({\n      groupSizePixels,\n      panelConstraints,\n      panelIndex: index,\n      size: unsafeSize,\n    });\n\n    if (unsafeSize != safeSize) {\n      remainingSize += unsafeSize - safeSize;\n\n      nextLayout[index] = safeSize;\n    }\n  }\n\n  // If there is additional, left over space, assign it to any panel(s) that permits it\n  // (It's not worth taking multiple additional passes to evenly distribute)\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\n    for (let index = 0; index < panelConstraints.length; index++) {\n      const prevSize = nextLayout[index]!;\n      const unsafeSize = prevSize + remainingSize;\n      const safeSize = resizePanel({\n        groupSizePixels,\n        panelConstraints,\n        panelIndex: index,\n        size: unsafeSize,\n      });\n\n      if (prevSize !== safeSize) {\n        remainingSize -= safeSize - prevSize;\n        nextLayout[index] = safeSize;\n\n        // Once we've used up the remainder, bail\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\n          break;\n        }\n      }\n    }\n  }\n\n  return nextLayout;\n}\n","import useUniqueId from \"./hooks/useUniqueId\";\nimport {\n  createElement,\n  CSSProperties,\n  ElementType,\n  MouseEvent as ReactMouseEvent,\n  ReactNode,\n  TouchEvent,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"./vendor/react\";\n\nimport { useWindowSplitterResizeHandlerBehavior } from \"./hooks/useWindowSplitterBehavior\";\nimport {\n  PanelGroupContext,\n  ResizeEvent,\n  ResizeHandler,\n} from \"./PanelGroupContext\";\nimport { getCursorStyle } from \"./utils/cursor\";\nimport { DataAttributes } from \"./types\";\n\nexport type PanelResizeHandleOnDragging = (isDragging: boolean) => void;\n\nexport type PanelResizeHandleProps = {\n  children?: ReactNode;\n  className?: string;\n  dataAttributes?: DataAttributes;\n  disabled?: boolean;\n  id?: string | null;\n  onDragging?: PanelResizeHandleOnDragging;\n  style?: CSSProperties;\n  tagName?: ElementType;\n};\n\nexport function PanelResizeHandle({\n  children = null,\n  className: classNameFromProps = \"\",\n  dataAttributes,\n  disabled = false,\n  id: idFromProps = null,\n  onDragging,\n  style: styleFromProps = {},\n  tagName: Type = \"div\",\n}: PanelResizeHandleProps) {\n  const divElementRef = useRef<HTMLDivElement>(null);\n\n  // Use a ref to guard against users passing inline props\n  const callbacksRef = useRef<{\n    onDragging: PanelResizeHandleOnDragging | undefined;\n  }>({ onDragging });\n  useEffect(() => {\n    callbacksRef.current.onDragging = onDragging;\n  });\n\n  const panelGroupContext = useContext(PanelGroupContext);\n  if (panelGroupContext === null) {\n    throw Error(\n      `PanelResizeHandle components must be rendered within a PanelGroup container`\n    );\n  }\n\n  const {\n    direction,\n    dragState,\n    groupId,\n    registerResizeHandle,\n    startDragging,\n    stopDragging,\n  } = panelGroupContext;\n\n  const resizeHandleId = useUniqueId(idFromProps);\n  const isDragging = dragState?.dragHandleId === resizeHandleId;\n\n  const [isFocused, setIsFocused] = useState(false);\n\n  const [resizeHandler, setResizeHandler] = useState<ResizeHandler | null>(\n    null\n  );\n\n  const stopDraggingAndBlur = useCallback(() => {\n    // Clicking on the drag handle shouldn't leave it focused;\n    // That would cause the PanelGroup to think it was still active.\n    const div = divElementRef.current!;\n    div.blur();\n\n    stopDragging();\n\n    const { onDragging } = callbacksRef.current;\n    if (onDragging) {\n      onDragging(false);\n    }\n  }, [stopDragging]);\n\n  useEffect(() => {\n    if (disabled) {\n      setResizeHandler(null);\n    } else {\n      const resizeHandler = registerResizeHandle(resizeHandleId);\n      setResizeHandler(() => resizeHandler);\n    }\n  }, [disabled, resizeHandleId, registerResizeHandle]);\n\n  useEffect(() => {\n    if (disabled || resizeHandler == null || !isDragging) {\n      return;\n    }\n\n    const onMove = (event: ResizeEvent) => {\n      resizeHandler(event);\n    };\n\n    const onMouseLeave = (event: MouseEvent) => {\n      resizeHandler(event);\n    };\n\n    const divElement = divElementRef.current!;\n    const targetDocument = divElement.ownerDocument;\n\n    targetDocument.body.addEventListener(\"contextmenu\", stopDraggingAndBlur);\n    targetDocument.body.addEventListener(\"mousemove\", onMove);\n    targetDocument.body.addEventListener(\"touchmove\", onMove);\n    targetDocument.body.addEventListener(\"mouseleave\", onMouseLeave);\n    window.addEventListener(\"mouseup\", stopDraggingAndBlur);\n    window.addEventListener(\"touchend\", stopDraggingAndBlur);\n\n    return () => {\n      targetDocument.body.removeEventListener(\n        \"contextmenu\",\n        stopDraggingAndBlur\n      );\n      targetDocument.body.removeEventListener(\"mousemove\", onMove);\n      targetDocument.body.removeEventListener(\"touchmove\", onMove);\n      targetDocument.body.removeEventListener(\"mouseleave\", onMouseLeave);\n      window.removeEventListener(\"mouseup\", stopDraggingAndBlur);\n      window.removeEventListener(\"touchend\", stopDraggingAndBlur);\n    };\n  }, [direction, disabled, isDragging, resizeHandler, stopDraggingAndBlur]);\n\n  useWindowSplitterResizeHandlerBehavior({\n    disabled,\n    handleId: resizeHandleId,\n    resizeHandler,\n  });\n\n  const style: CSSProperties = {\n    cursor: getCursorStyle(direction),\n    touchAction: \"none\",\n    userSelect: \"none\",\n  };\n\n  return createElement(Type, {\n    children,\n    className: classNameFromProps,\n    onBlur: () => setIsFocused(false),\n    onFocus: () => setIsFocused(true),\n    onMouseDown: (event: ReactMouseEvent) => {\n      startDragging(resizeHandleId, event.nativeEvent);\n\n      const { onDragging } = callbacksRef.current!;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    onMouseUp: stopDraggingAndBlur,\n    onTouchCancel: stopDraggingAndBlur,\n    onTouchEnd: stopDraggingAndBlur,\n    onTouchStart: (event: TouchEvent) => {\n      startDragging(resizeHandleId, event.nativeEvent);\n\n      const { onDragging } = callbacksRef.current!;\n      if (onDragging) {\n        onDragging(true);\n      }\n    },\n    ref: divElementRef,\n    role: \"separator\",\n    style: {\n      ...style,\n      ...styleFromProps,\n    },\n    tabIndex: 0,\n\n    ...dataAttributes,\n\n    // CSS selectors\n    \"data-panel-group-direction\": direction,\n    \"data-panel-group-id\": groupId,\n    \"data-resize-handle\": \"\",\n    \"data-resize-handle-active\": isDragging\n      ? \"pointer\"\n      : isFocused\n      ? \"keyboard\"\n      : undefined,\n    \"data-panel-resize-handle-enabled\": !disabled,\n    \"data-panel-resize-handle-id\": resizeHandleId,\n  });\n}\n\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\n","import { ResizeHandler } from \"../types\";\nimport { assert } from \"../utils/assert\";\nimport { getResizeHandleElement } from \"../utils/dom/getResizeHandleElement\";\nimport { getResizeHandleElementIndex } from \"../utils/dom/getResizeHandleElementIndex\";\nimport { getResizeHandleElementsForGroup } from \"../utils/dom/getResizeHandleElementsForGroup\";\nimport { useEffect } from \"../vendor/react\";\n\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\n\nexport function useWindowSplitterResizeHandlerBehavior({\n  disabled,\n  handleId,\n  resizeHandler,\n}: {\n  disabled: boolean;\n  handleId: string;\n  resizeHandler: ResizeHandler | null;\n}): void {\n  useEffect(() => {\n    if (disabled || resizeHandler == null) {\n      return;\n    }\n\n    const handleElement = getResizeHandleElement(handleId);\n    if (handleElement == null) {\n      return;\n    }\n\n    const onKeyDown = (event: KeyboardEvent) => {\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      switch (event.key) {\n        case \"ArrowDown\":\n        case \"ArrowLeft\":\n        case \"ArrowRight\":\n        case \"ArrowUp\":\n        case \"End\":\n        case \"Home\": {\n          event.preventDefault();\n\n          resizeHandler(event);\n          break;\n        }\n        case \"F6\": {\n          event.preventDefault();\n\n          const groupId = handleElement.getAttribute(\"data-panel-group-id\")!;\n\n          const handles = getResizeHandleElementsForGroup(groupId);\n          const index = getResizeHandleElementIndex(groupId, handleId);\n\n          assert(index !== null);\n\n          const nextIndex = event.shiftKey\n            ? index > 0\n              ? index - 1\n              : handles.length - 1\n            : index + 1 < handles.length\n            ? index + 1\n            : 0;\n\n          const nextHandle = handles[nextIndex] as HTMLDivElement;\n          nextHandle.focus();\n\n          break;\n        }\n      }\n    };\n\n    handleElement.addEventListener(\"keydown\", onKeyDown);\n    return () => {\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\n    };\n  }, [disabled, handleId, resizeHandler]);\n}\n"],"names":[],"version":3,"file":"react-resizable-panels.cjs.js.map","sourceRoot":"../../../"}